{
  
    
        "post0": {
            "title": "A new way to use the RDKit from other languages",
            "content": "TL;DR . We’ve added a new API which makes it easy to use the RDKit from programming languages other than C++, Python, Java or C#. . Intro . The majority of the RDKit is written in C++, but we also make wrappers allowing you to use it from other programming languages. The main one of these, and the most complete, is for Python and is written by hand (using Boost::Python). The Java and C# wrappers are generated more or less automatically using SWIG. . Back in 2019 we decided to do a JavaScript (JS) wrapper which follows a slightly different approach: instead of wrapping the whole toolkit the new JS wrappers provide access to a useful subset of RDKit functionality provided as functions. We called this MinimalLib and there’s more information in an earlier blog post. . We’ve now extended MinimalLib and made it useable from any programming language which supports calling into external libraries written in C (often called using a “C Foreign Function Interface”, or CFFI). Since most common programming languages support CFFI, I think this will help bring chemistry to a bunch of other languages. . How it works . This is easiest explained with an example. Since each programming language implements CFFI slightly differently, and I’m not even close to being good at some of the more intersting ones like go, Rust, or Julia, I’ll demonstrate using C itself and sample code adapted from cffi_test.c, one of the files used to test the new interface. . The general pattern when working with rdkit-cffi is to parse a molecule input format to get back a serialized (“pickled”) form of that molecule and then to pass that pickled molecule to other functions which do the chemistry operations you’re interested in. . Parsing molecule formats and operating on molecules . The “hello world” equivalent in cheminformatics is generating canonical SMILES. Here’s a full C program showing how you do that with rdkit-cffi, I will explain the rdkit-cffi functions and how they are used in more detail below: . #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; #include &quot;cffiwrapper.h&quot; void canon_smiles(){ char *pkl; size_t pkl_size; pkl = get_mol(&quot;c1cc(O)ccc1&quot;,&amp;pkl_size,&quot;&quot;); char *smiles=get_smiles(pkl,pkl_size,NULL); printf(&quot;Canonical SMILES: %s n&quot;,smiles); free(smiles); free(pkl); } int main(){ enable_logging(); printf(&quot;hello %s n&quot;,version()); canon_smiles(); return 0; } . I compiled this on my linux machine as follows: . % cc -o demo.exe -I $RDBASE/Code demo.c $RDBASE/lib/librdkitcffi.so . Running it produces: . % ./demo.exe hello 2021.09.1pre Canonical SMILES: Oc1ccccc1 . Let’s look at the rdkit-cffi parts of this, starting with the main() function. . We start by enabling the RDKit’s logging system: . enable_logging(); . If you skip this, you won’t see any of the usual RDKit errors or warnings. . Next we use the version() function to get the version of the RDKit which is being used and then print that out. . With that basic initialization out of the way we call the function canon_smiles(), which is where the real work happens. Here we start by parsing a SMILES using the get_mol() function: . pkl = get_mol(&quot;c1cc(O)ccc1&quot;,&amp;pkl_size,&quot;&quot;); . get_mol() returns a binary string with the pickled representation of the molecule and uses the pkl_size argument (an integer) to return the length of that string (this is an unfortunately necessary implementation detail). The final argument to get_mol(), the empty string, can be used to pass in an JSON string containing additional arguments controlling the parsing (we could have also passed this argument as NULL). get_mol() currently supports constructing molecules from SMILES (and CXSMILES), Mol/SDF, and the RDKit’s JSON format; it recognized automatically which parser should be used. We will be expanding the list of supported formats in the future. . After we have the molecule processed we can get the canonical SMILES for it by calling the get_smiles() function: . char *smiles=get_smiles(pkl,pkl_size,NULL); . get_smiles() follows the general pattern for rdkit-cffi functions which operate on molecules: the first two arguments are the pickled molecule and the length of the pickle string, the third argument is a JSON string with additional options to be used when generating the SMILES; in this case we want the defaults, so we pass a NULL pointer (we could also have used the empty string &quot;&quot;). . Finally, and not to be overlooked when working in C, we need to free the memory which was allocated to hold the molecule pickle and the SMILES: . free(smiles); free(pkl); . The functions which are available are declared in cffiwrapper.h. . Modifying molecules . Some rdkit-cffi functions modify the molecule. In this case the general pattern is the modify the molecule in place, i.e. to modify the current molecule instead of returning a new one. . Here’s a simple function which parses a SMILES, add Hs to the molecule, generates a 3D conformer using a fixed random seed, and then prints out the molblock for the modified molecule: . void generate_conformer(){ char *pkl; size_t pkl_size; pkl = get_mol(&quot;c1cc(O)ccc1&quot;,&amp;pkl_size,NULL); add_hs(&amp;pkl,&amp;pkl_size); set_3d_coords(&amp;pkl,&amp;pkl_size,&quot;{ &quot;randomSeed &quot;:42}&quot;); char *molb = get_molblock(pkl,pkl_size,NULL); printf(&quot;%s n&quot;,molb); free(molb); free(pkl); } . We’ve already seen get_mol(). As mentioned above add_hs() modifies the molecule in place, so you need to pass pointers to the pickle string and pickle size so that they can be modifed. set_3d_coords() also modifies the molecule in place to add the conformer. This is also the first time we use the JSON string that most of the functions take as their last argument: here we set the random number seed used in the conformer generation so that we get reproducible results. Finally get_molblock(), like get_smiles(), returns a string with the MOL file data for the molecule. This can be saved to a file and opened in most chemistry software. . An aside about an interesting way rdkit-cffi could be used . The RDKit has a lot of functionality, and covering all of that in the interface exposed by rdkit-cffi is not a goal. We want to provide a useful (hopefully very useful) subset of the functionality for use in other languages. If there’s something you think is missing, please ask about it. . I think you there’s another interesting use case for this though. Suppose you have an idea for some interesting new piece of cheminformatics functionality, and you’d like to work in a language like Rust or Julia but you don’t want to have to deal with all the basic cheminformatics plumbing yourself. rdkit-cffi can really help here. The key functionality for this mode is the get_json() function, which returns an easily parsed JSON representation of the molecule using the RDKit’s extension to the commonchem JSON format. . void json_output(){ char *pkl; size_t pkl_size; pkl = get_mol(&quot;c1cc(O)ccc1&quot;,&amp;pkl_size,&quot;&quot;); char *json=get_json(pkl,pkl_size,NULL); printf(&quot;%s n&quot;,json); free(json); free(pkl); } . The output here (after running through a JSON pretty printer) is: . { &quot;commonchem&quot;: { &quot;version&quot;: 10 }, &quot;defaults&quot;: { &quot;atom&quot;: { &quot;z&quot;: 6, &quot;impHs&quot;: 0, &quot;chg&quot;: 0, &quot;nRad&quot;: 0, &quot;isotope&quot;: 0, &quot;stereo&quot;: &quot;unspecified&quot; }, &quot;bond&quot;: { &quot;bo&quot;: 1, &quot;stereo&quot;: &quot;unspecified&quot; } }, &quot;molecules&quot;: [ { &quot;atoms&quot;: [ { &quot;impHs&quot;: 1 }, { &quot;impHs&quot;: 1 }, {}, { &quot;z&quot;: 8, &quot;impHs&quot;: 1 }, { &quot;impHs&quot;: 1 }, { &quot;impHs&quot;: 1 }, { &quot;impHs&quot;: 1 } ], &quot;bonds&quot;: [ { &quot;bo&quot;: 2, &quot;atoms&quot;: [0,1] }, { &quot;atoms&quot;: [1,2] }, { &quot;atoms&quot;: [2,3] }, { &quot;bo&quot;: 2, &quot;atoms&quot;: [2,4] }, { &quot;atoms&quot;: [4,5] }, { &quot;bo&quot;: 2, &quot;atoms&quot;: [5,6] }, { &quot;atoms&quot;: [6,0] } ], &quot;extensions&quot;: [ { &quot;name&quot;: &quot;rdkitRepresentation&quot;, &quot;formatVersion&quot;: 1, &quot;toolkitVersion&quot;: &quot;2021.09.1pre&quot;, &quot;aromaticAtoms&quot;: [0,1,2,4,5,6], &quot;aromaticBonds&quot;: [0,1,3,4,5,6], &quot;atomRings&quot;: [[0,6,5,4,2,1] ] } ] } ] } . It should be easy to parse this with the JSON parser in any modern programming language, and the format provides all the information you need to reconstruct a molecule in whatever representation you’re using in your language of choice. But you can do it without having to worry about dealing with chemistry perception, ring finding, etc. . Status . The new CFFI interface is currently available on the RDKit master branch. It hasn’t yet been officially released, but I’m publicizing it now because I’d like to try and get people using it and providing feedback and suggestions so that we can get it as polished and useful as possible before the 2021.09 release later this year. . I’ve setup a separate repo in github which has a link to Azure Pipelines to automatically do builds of the CFFI wrappers and make the shared libraries available. The README there also includes links you can use to download the most recent builds for Linux and the Mac (I still need to get the automated Windows builds working). I haven’t figured out how to actually make this easy (unless you have the azure CLI installed, in which case there’s a single command you can execute), so there are a number of clicks needed: . Start by picking the build you want from the README: . Now click the build identifier (this page also has the azure CLI command to get the build directly): . Pick the appropriate job: . Click the “1 artifact” link: . now you can actually download the artifact: . sigh I will try to find a way to make this simpler… . Wrapping up . I will likely do another post on rdkit-cffi before the next release, most likely one looking at things like performance (since that’s something I tend to do). In the meantime please let me know if you start using it! .",
            "url": "https://greglandrum.github.io/rdkit-blog/technical/2021/05/01/rdkit-cffi-part1.html",
            "relUrl": "/technical/2021/05/01/rdkit-cffi-part1.html",
            "date": " • May 1, 2021"
        }
        
    
  
    
        ,"post1": {
            "title": "Intro to the molecule enumerator",
            "content": "The V3000 mol file format allows a number of interesting and useful advanced query features. Here I&#39;ll look at two of them: position variation bonds (a.k.a. variable attachment points) and link nodes. . This blog post uses features from the 2021.03.1 RDKit release; some of this will not work with older releases. . from rdkit import Chem from rdkit.Chem.Draw import rdDepictor from rdkit.Chem import Draw from rdkit.Chem.Draw import IPythonConsole from rdkit.Chem import rdMolEnumerator import rdkit print(rdkit.__version__) . 2021.03.1 . Position variation bonds . Here&#39;s a molecule with a position variation bond: . pv1 = Chem.MolFromMolBlock(&#39;&#39;&#39; Mrv2007 06232015292D 0 0 0 0 0 999 V3000 M V30 BEGIN CTAB M V30 COUNTS 9 8 0 0 0 M V30 BEGIN ATOM M V30 1 C -1.7083 2.415 0 0 M V30 2 C -3.042 1.645 0 0 M V30 3 C -3.042 0.105 0 0 M V30 4 N -1.7083 -0.665 0 0 M V30 5 C -0.3747 0.105 0 0 M V30 6 C -0.3747 1.645 0 0 M V30 7 * -0.8192 1.3883 0 0 M V30 8 O -0.8192 3.6983 0 0 M V30 9 C 0.5145 4.4683 0 0 M V30 END ATOM M V30 BEGIN BOND M V30 1 1 1 2 M V30 2 2 2 3 M V30 3 1 3 4 M V30 4 2 4 5 M V30 5 1 5 6 M V30 6 2 1 6 M V30 7 1 7 8 ENDPTS=(3 1 5 6) ATTACH=ANY M V30 8 1 8 9 M V30 END BOND M V30 END CTAB M END&#39;&#39;&#39;) pv1 . The query is describing a molecule consisting of a pyriding ring with an methoxy substituted either ortho, meta, or para to the N atom. . The RDKit includes functionality in the rdkit.Chem.rdMolEnumerator module which allows you enumerate all of the molecules which are described by this query. . The function rdMolEnumerator.Enumerate() is straightforward to use: given a molecule with supported query features it returns a MolBundle object which includes each possible expansion of the query: . pv1_bundle = rdMolEnumerator.Enumerate(pv1) pv1_bundle . &lt;rdkit.Chem.rdchem.MolBundle at 0x7fc138399b20&gt; . We can render the molecules in the bundle using Draw.MolsToGridImage(): . Draw.MolsToGridImage(pv1_bundle) . These are pretty ugly since the enumeration hasn&#39;t generated new coordinates for the atom which correspond to the new connectivity. . I&#39;ll use this convenience function to find the common core shared by the molecules in a bundle and generate 2D coordinates for all the molecules with the core oriented consistently: . from rdkit.Chem import rdFMCS def align_bundle_coords(bndl): ps = rdFMCS.MCSParameters() for m in bndl: Chem.SanitizeMol(m) mcs = rdFMCS.FindMCS(bndl,completeRingsOnly=True) q = Chem.MolFromSmarts(mcs.smartsString) rdDepictor.Compute2DCoords(q) for m in bndl: rdDepictor.GenerateDepictionMatching2DStructure(m,q) . Now let&#39;s apply that to our bundle: . pv1_bundle = rdMolEnumerator.Enumerate(pv1) align_bundle_coords(pv1_bundle) Draw.MolsToGridImage(pv1_bundle) . Of course a molecule can have more than one position variation bond: . pv2 = Chem.MolFromMolBlock(&#39;&#39;&#39; Mrv2007 06242006032D 0 0 0 0 0 999 V3000 M V30 BEGIN CTAB M V30 COUNTS 10 8 0 0 0 M V30 BEGIN ATOM M V30 1 C -1.7083 2.415 0 0 M V30 2 C -3.042 1.645 0 0 M V30 3 C -3.042 0.105 0 0 M V30 4 N -1.7083 -0.665 0 0 M V30 5 C -0.3747 0.105 0 0 M V30 6 C -0.3747 1.645 0 0 M V30 7 * -3.042 0.875 0 0 M V30 8 F -5.0434 0.875 0 0 M V30 9 * -1.0415 2.03 0 0 M V30 10 Cl -1.0415 4.34 0 0 M V30 END ATOM M V30 BEGIN BOND M V30 1 1 1 2 M V30 2 2 2 3 M V30 3 1 3 4 M V30 4 2 4 5 M V30 5 1 5 6 M V30 6 2 1 6 M V30 7 1 7 8 ENDPTS=(2 2 3) ATTACH=ANY M V30 8 1 9 10 ENDPTS=(2 1 6) ATTACH=ANY M V30 END BOND M V30 END CTAB M END &#39;&#39;&#39;) pv2 . This is also supported by the enumerator: . pv2_bundle = rdMolEnumerator.Enumerate(pv2) align_bundle_coords(pv2_bundle) Draw.MolsToGridImage(pv2_bundle) . Link nodes . Another useful query feature, link nodes, allow you to describe rings of various sizes or chains with different lengths: . link1 = Chem.MolFromMolBlock(&#39;&#39;&#39;one linknode Mrv2007 06222005102D 0 0 0 0 0 999 V3000 M V30 BEGIN CTAB M V30 COUNTS 6 6 0 0 0 M V30 BEGIN ATOM M V30 1 C 8.25 12.1847 0 0 M V30 2 C 6.9164 12.9547 0 0 M V30 3 C 6.9164 14.4947 0 0 M V30 4 C 9.5836 14.4947 0 0 M V30 5 C 9.5836 12.9547 0 0 M V30 6 O 8.25 10.6447 0 0 M V30 END ATOM M V30 BEGIN BOND M V30 1 1 1 2 M V30 2 1 2 3 M V30 3 1 4 5 M V30 4 1 1 5 M V30 5 1 3 4 M V30 6 1 1 6 M V30 END BOND M V30 LINKNODE 1 4 2 1 2 1 5 M V30 END CTAB M END&#39;&#39;&#39;) link1 . And we can enumerate and display these in the same way. Here there&#39;s not much sense in doing the MCS analysis to get the shared coordinates, so I just generate coordinates for the molecules directly: . link1_bundle = rdMolEnumerator.Enumerate(link1) for m in link1_bundle: Chem.SanitizeMol(m) rdDepictor.Compute2DCoords(m) Draw.MolsToGridImage(link1_bundle) . Combining them . We can also combine link nodes and position variation bonds in the same molecule: . combined = Chem.MolFromMolBlock(&#39;&#39;&#39; Mrv2108 05132110052D 0 0 0 0 0 999 V3000 M V30 BEGIN CTAB M V30 COUNTS 19 20 0 0 0 M V30 BEGIN ATOM M V30 1 N -2.2078 4.3165 0 0 M V30 2 C -2.9544 2.9695 0 0 M V30 3 C -2.1612 1.6495 0 0 M V30 4 C -0.6214 1.6763 0 0 M V30 5 C 0.1252 3.0233 0 0 M V30 6 C -0.668 4.3433 0 0 M V30 7 C 1.6649 3.0501 0 0 M V30 8 C -4.4941 2.9427 0 0 M V30 9 C 2.4581 1.7301 0 0 M V30 10 C 2.985 3.8433 0 0 M V30 11 C 3.7781 2.5233 0 0 M V30 12 C -6.3747 4.5774 0 0 M V30 13 C -6.9764 3.1598 0 0 M V30 14 C -5.8142 2.1495 0 0 M V30 15 C -4.8405 4.4431 0 0 M V30 16 F -7.1678 5.8974 0 0 M V30 17 O 3.3575 5.3376 0 0 M V30 18 * -1.1502 2.5564 0 0 M V30 19 C -1.1502 0.2464 0 0 M V30 END ATOM M V30 BEGIN BOND M V30 1 1 1 2 M V30 2 2 2 3 M V30 3 1 3 4 M V30 4 2 4 5 M V30 5 1 5 6 M V30 6 2 1 6 M V30 7 1 5 7 M V30 8 1 2 8 M V30 9 1 9 11 M V30 10 1 10 11 M V30 11 1 7 9 M V30 12 1 7 10 M V30 13 1 12 13 M V30 14 1 13 14 M V30 15 1 12 15 M V30 16 1 14 8 M V30 17 1 8 15 M V30 18 1 12 16 M V30 19 1 10 17 M V30 20 1 18 19 ENDPTS=(3 6 3 4) ATTACH=ANY M V30 END BOND M V30 LINKNODE 1 2 2 10 7 10 11 M V30 LINKNODE 1 2 2 12 13 12 15 M V30 END CTAB M END &#39;&#39;&#39;) combined . Enumerating that produces 12 molecules: . combined_bundle = rdMolEnumerator.Enumerate(combined) align_bundle_coords(combined_bundle) Draw.MolsToGridImage(combined_bundle,subImgSize=(300,250)) . Using MolBundles for substructure search . MolBundles can also be used as substructure search queries. . Here&#39;s another query molecule: . qry= Chem.MolFromMolBlock(&#39;&#39;&#39; Mrv2108 05132113572D 0 0 0 0 0 999 V3000 M V30 BEGIN CTAB M V30 COUNTS 13 13 0 0 0 M V30 BEGIN ATOM M V30 1 C 1.2124 -2.4845 0 0 M V30 2 N 2.5461 -3.2545 0 0 M V30 3 C 2.5461 -4.7945 0 0 M V30 4 C 1.2124 -5.5645 0 0 M V30 5 C 1.2124 -7.1045 0 0 M V30 6 C -0.0335 -8.0097 0 0 M V30 7 O 0.4424 -9.4744 0 0 M V30 8 C 1.9824 -9.4744 0 0 M V30 9 C 2.4583 -8.0097 0 0 M V30 10 C -0.1212 -4.7945 0 0 M V30 11 C -0.1212 -3.2545 0 0 M V30 12 * 0.5456 -2.8695 0 0 M V30 13 C -0.6094 -0.869 0 0 M V30 END ATOM M V30 BEGIN BOND M V30 1 2 1 2 M V30 2 1 2 3 M V30 3 2 3 4 M V30 4 1 4 5 M V30 5 1 6 7 M V30 6 1 7 8 M V30 7 1 8 9 M V30 8 1 5 9 M V30 9 1 4 10 M V30 10 2 10 11 M V30 11 1 1 11 M V30 12 1 12 13 ENDPTS=(2 11 1) ATTACH=ANY M V30 13 1 5 6 M V30 END BOND M V30 LINKNODE 1 2 2 6 5 6 7 M V30 END CTAB M END &#39;&#39;&#39;) qry . And a set of molecules to search through which I pulled from ChEMBL . smis = &#39;&#39;&#39;Cc1nc(C(C)(C)NC(=O)c2ccc(C3CCOCC3)c(OCC3CC3)n2)no1 CC(C)(CO)NC(=O)c1ccc(C2CCOC2)c(OCC2CC2)n1 CC(C)(NC(=O)c1ccc(C2CCOCC2)c(OCC2CC2)n1)c1nccs1 Cc1c(-c2cncc(C3(O)CCOCC3)c2)cnc2c1CCCN2C(N)=O CC(C)Oc1cc(NC(=O)N2CCCc3cc(C4CCOC4)c(C=O)nc32)ncc1C#N NC(=O)N1CCCc2cc(-c3cncc(C4(O)CCOC4)c3)cnc21 CCC(CC)(NC(=O)c1ccc(C2CCOCC2)c(OCC2CC2)n1)C(=O)NC CC(C)(NC(=O)c1ccc(C2CCOCC2)c(OCC2CC2)n1)c1ncco1 N#Cc1cc(-c2ccoc2)c2ccc(OCc3cncc(C4(O)CCOCC4)c3)cc2c1 Nc1cc(-c2cc(C3CCOCC3)cnc2N)ccc1C(=O)N[C@H](CO)c1ccccc1 Nc1ncc(C2CCOCC2)cc1-c1ccc(C(=O)NCc2cccnc2)cc1 Cc1nc(C(C)(C)NC(=O)c2ccc(C3CCOC3)c(OCC3CC3)n2)no1 CC(C)C[C@H](NC(=O)c1ccc(C2CCOC2)c(OCC2CC2)n1)C(N)=O Nc1ncc(C2CCOCC2)cc1-c1ccc(C(=O)N[C@H](CO)c2ccccc2)cc1Cl NC(=O)[C@H](CC1CC1)NC(=O)c1ccc(C2CCOC2)c(OCC2CC2)n1 &#39;&#39;&#39; mols = [Chem.MolFromSmiles(x.strip()) for x in smis.split(&#39; n&#39;) if x.strip()] . The query itself doesn&#39;t match most of these molecules: . matches = [x for x in mols if x.HasSubstructMatch(qry)] len(mols),len(matches) . (15, 6) . But if we enumerate it into a MolBundle and use that as the substructure query then all the molecules match: . qry_bundle = rdMolEnumerator.Enumerate(qry) matches = [x for x in mols if x.HasSubstructMatch(qry_bundle)] len(mols),len(matches) . (15, 15) . Let&#39;s look at a few of those matches . matches = [] matched_ats = [] for x in mols: match = x.GetSubstructMatch(qry_bundle) if match: matches.append(x) matched_ats.append(match) Draw.MolsToGridImage(matches[:6],highlightAtomLists=matched_ats,subImgSize=(300,250)) . We&#39;re working on expanding support for the MolBundle in other RDKit code. For example, it would be really nice to be able to use them directly as queries for the SubstructLibrary . Final bit: input from CXSMILES . It&#39;s also possible to read both variable attachment points and link nodes from CXSMILES: . m = Chem.MolFromSmiles(&#39;CO*.C1=CC=NC=C1 |c:2,4,6,m:2:3.5.4|&#39;) m . As that example shows, the coordinate generation code is currently not great at setting the atom positions for these. That&#39;s a ToDo for a future release. . m = Chem.MolFromSmiles(&#39;OC1CCCC1 |LN:1:1.4.2.5|&#39;) m . The RDKit currently does not write either link nodes or variable attachment points to CXSMILES, that&#39;s another ToDo for a future release. .",
            "url": "https://greglandrum.github.io/rdkit-blog/tutorial/substructure/2021/03/13/intro-to-the-molecule-enumerator.html",
            "relUrl": "/tutorial/substructure/2021/03/13/intro-to-the-molecule-enumerator.html",
            "date": " • Mar 13, 2021"
        }
        
    
  
    
        ,"post2": {
            "title": "ETKDG and distance constraints",
            "content": "The RDKit&#39;s conformer generator allows you to provide distance &quot;constraints&quot; to bias the conformers which it produces. Last week I wondered how those constraints interact with the terms which the ETKDG algorithm adds to the &quot;distance geometry force field&quot;. . This post uses a simple example to explore that interaction . See another recent blog post for an overview of how the conformer generator works. . from rdkit import Chem from rdkit.Chem import rdDistGeom from rdkit.Chem.Draw import IPythonConsole from rdkit.Chem import rdMolTransforms IPythonConsole.ipython_3d = True from rdkit.Chem import Draw import rdkit print(rdkit.__version__) %pylab inline . 2020.09.4 Populating the interactive namespace from numpy and matplotlib . Here&#39;s the molecule we&#39;ll use: . m = Chem.AddHs(Chem.MolFromSmiles(&#39;OCCCCCCCN&#39;)) . from rdkit.Chem import rdDepictor m2d = Chem.Mol(m) rdDepictor.Compute2DCoords(m2d) IPythonConsole.drawOptions.addAtomIndices = True m2d . Get the bounds matrix for the molecule and look at the min/max values allowed for the O-N distance: . bounds = rdDistGeom.GetMoleculeBoundsMatrix(m) bounds[8,0],bounds[0,8] . (3.1500000000000004, 9.902933132591349) . Let&#39;s generate a bunch of conformers and look at the distribution of O-N distances: . figsize(6,6) ps = rdDistGeom.ETKDGv3() ps.randomSeed = 0xf00d cids = rdDistGeom.EmbedMultipleConfs(m,500,ps) dists_etkdg = [rdMolTransforms.GetBondLength(conf,0,8) for conf in m.GetConformers()] hist(dists_etkdg,bins=20); title(&#39;ETKDG&#39;); xlabel(&#39;O--N distance&#39;); . Look at one conformer: . print(rdMolTransforms.GetBondLength(m.GetConformer(cids[0]),0,8) ) IPythonConsole.drawMol3D(m,confId=cids[1]) . 5.989729201561945 . You appear to be running in JupyterLab (or JavaScript failed to load for some other reason). You need to install the 3dmol extension: jupyter labextension install jupyterlab_3dmol . Compare the distribution we get doing plain DG: . figsize(6,6) ps = rdDistGeom.EmbedParameters() ps.useExpTorsionAnglePrefs = False ps.useBasicKnowledge = False ps.randomSeed = 0xf00d cids = rdDistGeom.EmbedMultipleConfs(m,500,ps) dists = [rdMolTransforms.GetBondLength(conf,0,8) for conf in m.GetConformers()] hist(dists,bins=20); title(&#39;DG&#39;); xlabel(&#39;O--N distance&#39;); . There&#39;s not a giant difference, but it does look like the DG conformers for this molecule tend to be more extended: the O and N tend to be farther away from each other. . Here&#39;s how we can modify the bounds matrix to bring the O and N closer together: . bounds[0,8] = 4.1 bounds[8,0] = 4.0 from rdkit import DistanceGeometry DistanceGeometry.DoTriangleSmoothing(bounds) . True . Start with using this bounds matrix together with plain DG: . figsize(6,6) ps = rdDistGeom.EmbedParameters() ps.useExpTorsionAnglePrefs = False ps.useBasicKnowledge = False ps.randomSeed = 0xf00d ps.SetBoundsMat(bounds) cids = rdDistGeom.EmbedMultipleConfs(m,500,ps) dists = [rdMolTransforms.GetBondLength(conf,0,8) for conf in m.GetConformers()] hist(dists,bins=20); title(&#39;DG, distance constraints&#39;); xlabel(&#39;O--N distance&#39;); . print(rdMolTransforms.GetBondLength(m.GetConformer(cids[0]),0,8) ) IPythonConsole.drawMol3D(m,confId=cids[0]) . 3.9739942608788374 . You appear to be running in JupyterLab (or JavaScript failed to load for some other reason). You need to install the 3dmol extension: jupyter labextension install jupyterlab_3dmol . When we do ETKDG we add additional terms to the force field that&#39;s used to optimize the structure. Do these override our distance constraints? . figsize(6,6) ps = rdDistGeom.ETKDGv3() ps.randomSeed = 0xf00d ps.SetBoundsMat(bounds) cids = rdDistGeom.EmbedMultipleConfs(m,500,ps) dists = [rdMolTransforms.GetBondLength(conf,0,8) for conf in m.GetConformers()] hist(dists,bins=20); title(&#39;ETKDG with constraints&#39;); xlabel(&#39;O--N distance&#39;); . Most of the distances are longer than what we were looking for, but they are still considerably shorter than what we saw before: . figsize(9,6) ps = rdDistGeom.ETKDGv3() ps.randomSeed = 0xf00d ps.SetBoundsMat(bounds) cids = rdDistGeom.EmbedMultipleConfs(m,500,ps) dists = [rdMolTransforms.GetBondLength(conf,0,8) for conf in m.GetConformers()] hist(dists,bins=20,label=&#39;constraints&#39;); title(&#39;ETKDG&#39;); hist(dists_etkdg,bins=20,label=&#39;no constraints&#39;); legend(); xlabel(&#39;O--N distance&#39;); . So that answers our original question: the &quot;constraints&quot; we place on the conformers by modifying the bounds matrix aren&#39;t strict, so the additional terms added by ETKDG can result in them being violated. But the results are still significant biased towards the region of conformer space we wanted to explore. . Let&#39;s try forcing conformations which have distances consistent with an intra-molecular hydrogen bond. Here we need to modify the bounds matrix elements between both the O and the N as well as the O and one of the Hs attached to the N. If we don&#39;t adjust the O-N distance bounds too we end up with a bounds matrix which cannot be smoothed. . bounds = rdDistGeom.GetMoleculeBoundsMatrix(m) bounds[0,25] = 1.9 bounds[25,0] = 1.8 bounds[0,8] = 3.2 bounds[8,0] = 2.9 from rdkit import DistanceGeometry DistanceGeometry.DoTriangleSmoothing(bounds) . True . figsize(9,6) ps = rdDistGeom.EmbedParameters() ps.useExpTorsionAnglePrefs = False ps.useBasicKnowledge = False ps.randomSeed = 0xf00d ps.SetBoundsMat(bounds) cids = rdDistGeom.EmbedMultipleConfs(m,500,ps) dists = [rdMolTransforms.GetBondLength(conf,0,25) for conf in m.GetConformers()] hist(dists,bins=20); xlabel(&#39;O--H-N distance&#39;); . print(rdMolTransforms.GetBondLength(m.GetConformer(cids[0]),0,25) ) IPythonConsole.drawMol3D(m,confId=cids[0]) . 1.9045497511922502 . You appear to be running in JupyterLab (or JavaScript failed to load for some other reason). You need to install the 3dmol extension: jupyter labextension install jupyterlab_3dmol . Try using ETKDG: . figsize(6,6) ps = rdDistGeom.ETKDGv3() ps.randomSeed = 0xf00d ps.SetBoundsMat(bounds) cids = rdDistGeom.EmbedMultipleConfs(m,500,ps) dists = [rdMolTransforms.GetBondLength(conf,0,25) for conf in m.GetConformers()] hist(dists,bins=20); title(&#39;ETKDG, with constraints&#39;); xlabel(&#39;O--H-N distance&#39;); . print(rdMolTransforms.GetBondLength(m.GetConformer(cids[0]),0,25) ) IPythonConsole.drawMol3D(m,confId=cids[0]) . 2.0641816694294173 . You appear to be running in JupyterLab (or JavaScript failed to load for some other reason). You need to install the 3dmol extension: jupyter labextension install jupyterlab_3dmol . The O--H-N distances here aren&#39;t completely obeying the 1.8-1.9 distance bounds we imposed, but they seem to match a bit better than what we saw above when we constrained the O--N distance. I think that&#39;s likely because now we have an additional constraining term - the O--H distance as well as the O--N distance - to help override the ETKDG preferences. . So to repeat the conclusion: modifying the distance bounds matrix doesn&#39;t act as a hard constraint when we include ETKDG terms in the conformer generation process, but it definitely biases the results towards the areas of conformer space which we were trying to access. .",
            "url": "https://greglandrum.github.io/rdkit-blog/conformers/exploration/2021/02/22/etkdg-and-distance-constraints.html",
            "relUrl": "/conformers/exploration/2021/02/22/etkdg-and-distance-constraints.html",
            "date": " • Feb 22, 2021"
        }
        
    
  
    
        ,"post3": {
            "title": "Looking at random-coordinate embedding",
            "content": "This post discusses and shows the impact of the useRandomCoords option for the RDKit&#39;s conformer generator. . The RDKit&#39;s conformation generator is based on distance geometry. Here are the basic steps for the standard approach: . The molecule&#39;s distance bounds matrix is calculated based on the connection table and a set of rules. | The bounds matrix is smoothed using a triangle-bounds smoothing algorithm. | A random distance matrix that satisfies the bounds matrix is generated. | This distance matrix is embedded in 3 or 4 dimensions (producing coordinates for each atom). | The resulting coordinates are cleaned up somewhat using a crude force field (the &quot;distance geometry force field&quot;) and the bounds matrix. | If 4D embedding was done: another minimization is done with the distance geometry force field including a term to drive the 4th coordinate to zero. | If either experimental torsions (ET) or basic knowledge terms (K) are being used (the default is to use both because the conformations are higher quality), a final minimization is done using the &quot;ET&quot;, &quot;K&quot;, or &quot;ETK&quot; force fields. | Another way to generate the initial set of coordinates is to replace steps 3 and 4 with just picking a set of random coordinates (i.e. scatter the atoms randomly about a 3D box) and then moving on to step 5 and minimizing those using the distance geometry force field mentioned above. I learned of this approach from David Spellmeyer, who published it back in 1997: https://doi.org/10.1016/S1093-3263(97)00014-4 . Starting from random coordinates has been possible within the RDKit more or less since the beginning (I&#39;ve known David a long time ;-), but it&#39;s not the default because my implementation of it was slower than the standard embedding approach in the early testing and validation work I did. I&#39;ve been saying for years that random-coordinate embedding is more robust (though slower), but I haven&#39;t actually gone back and tested/quantified that since my initial experiments. This blog post aims to clear some of that up. . TL;DR: I ran some experiments using a set of 900 molecules with varying numbers of rotatable bonds and two different macrocycle sizes. Each molecule has at least two specified stereocenters. Given the current implementation, random-coordinate embedding is more robust - it&#39;s more likely to produce the requested number of conformers for these structures than the standard metric embedding is - but it still tends to be a bit slower. . Here&#39;s a graphical summary of the results: The main conclusion about timing can be see by comparing the red (metric) and blue (random) data. . Here&#39;s a plot comparing how long it takes to generate each conformer when trying for 50 conformers (left) or 50 more diverse conformers (right), the plot has been zoomed in, so a few extreme outliers (which impact the standard metric embedding more severely than the random-coordinate embedding) are not visible. . . Given that it is certainly more robust and that the overall performance difference isn&#39;t huge, I think I&#39;m likely to switch to using random-coordinate embedding for my future work. Maybe we can think about making it the default in the RDKit too. . For those who are interested, here&#39;s the original literature about ETKDG: . The original ETKDG publication: https://pubs.acs.org/doi/abs/10.1021/acs.jcim.5b00654 | Sereina Riniker&#39;s presentation at the 2015 RDKit UGM: https://github.com/rdkit/UGM_2015/blob/master/Presentations/ETKDG.SereinaRiniker.pdf | An update describing ETKDGv3 and extensions to better handle small rings and macrocycles: https://pubs.acs.org/doi/abs/10.1021/acs.jcim.0c00025 | . If you want to play with the compounds yourself, the SMILES are all in the rdkit_blog github repo . Ok, let&#39;s get to work and generate the data. . from rdkit import Chem from rdkit.Chem import Draw from rdkit.Chem.Draw import IPythonConsole from rdkit.Chem import rdDepictor rdDepictor.SetPreferCoordGen(True) import pandas as pd import rdkit print(rdkit.__version__) %load_ext sql %pylab inline . 2020.09.4 The sql extension is already loaded. To reload it, use: %reload_ext sql Populating the interactive namespace from numpy and matplotlib . Collecting test molecules from ChEMBL . For this exercise I want a set of molecules which have varying numbers of rotatable bonds and which include at least two specified chiral centers. I include the constraint on chiral centers because the RDKit&#39;s conformation generator normally only returns conformations which match the specified stereochemistry. This can make conformation generation slower and I&#39;m curious to see the impact of that as part of this post. . Start with a few queries against my local copy of ChEMBL27 to see how many molecules with at least two specified chiral centers are available with different numbers of rotatable bonds: . %sql postgresql://localhost/chembl_27 select count(*) from compound_properties join compound_structures using (molregno) where rtb = 2 and array_length(regexp_split_to_array(canonical_smiles,&#39;@+&#39;),1)-1 &gt;2; . 1 rows affected. . count . 14904 | . %sql postgresql://localhost/chembl_27 select count(*) from compound_properties join compound_structures using (molregno) where rtb = 5 and array_length(regexp_split_to_array(canonical_smiles,&#39;@+&#39;),1)-1 &gt;2; . 1 rows affected. . count . 20586 | . %sql postgresql://localhost/chembl_27 select count(*) from compound_properties join compound_structures using (molregno) where rtb = 10 and array_length(regexp_split_to_array(canonical_smiles,&#39;@+&#39;),1)-1 &gt;2; . 1 rows affected. . count . 9845 | . %sql postgresql://localhost/chembl_27 select count(*) from compound_properties join compound_structures using (molregno) where rtb = 15 and array_length(regexp_split_to_array(canonical_smiles,&#39;@+&#39;),1)-1 &gt;2; . 1 rows affected. . count . 3834 | . %sql postgresql://localhost/chembl_27 select count(*) from compound_properties join compound_structures using (molregno) where rtb = 25 and array_length(regexp_split_to_array(canonical_smiles,&#39;@+&#39;),1)-1 &gt;2; . 1 rows affected. . count . 1129 | . Looks like we can get plenty of molecules with up to 25 rotatable bonds, so let&#39;s go ahead and collect a set of 100 molecules for each of the rotatable bond counts 1, 2, 5, 10, 15, 20, and 25. I also include two additional sets of 100 molecules: one which contains at least one ring of size 10 and one which contains at least one ring of size 14. These macrocycles show up in what comes below with negative numbers of rotatable bonds: -10 for the compounds with a 10-ring and -14 for compounds with a 14-ring. . overall_data = [] for tgt in (1,2,5,10,15,20,25): d = %sql postgresql://localhost/chembl_27 select * from (select canonical_smiles,chembl_id,rtb from compound_properties join compound_structures using (molregno) join chembl_id_lookup on (molregno=entity_id and entity_type=&#39;COMPOUND&#39;) where rtb = :tgt and mw_freebase = full_mwt and array_length(regexp_split_to_array(canonical_smiles,&#39;@+&#39;),1)-1 &gt;2) tmp order by random() limit 100; overall_data.extend(d) for tgt in (10,14): sma = f&#39;[r{tgt}]&#39; d = %sql postgresql://localhost/chembl_27 select * from (select canonical_smiles,chembl_id,-1 * :tgt from compound_properties join compound_structures using (molregno) join rdk.mols using (molregno) join chembl_id_lookup on (molregno=entity_id and entity_type=&#39;COMPOUND&#39;) where m@&gt;:sma ::qmol and mw_freebase = full_mwt and array_length(regexp_split_to_array(canonical_smiles,&#39;@+&#39;),1)-1 &gt;2) tmp order by random() limit 100; overall_data.extend(d) with open(&#39;../data/chembl27_confgen_tgts.txt&#39;,&#39;w+&#39;) as outf: outf.write(&#39;SMILES CHEMBL_ID RTB n&#39;) for line in overall_data: outf.write(&#39; &#39;.join(str(x) for x in line)+&#39; n&#39;) . 100 rows affected. 100 rows affected. 100 rows affected. 100 rows affected. 100 rows affected. 100 rows affected. 100 rows affected. 100 rows affected. 100 rows affected. . !head ../data/chembl27_confgen_tgts.txt . SMILES CHEMBL_ID RTB C[C@@H]1C[C@@]2(C)[C@@H](CC[C@H]3[C@@H]4CC[C@H](O)[C@@]4(C)CC[C@@H]32)C/C1=N N=C1/C[C@@H]2CC[C@H]3[C@@H]4CC[C@H](O)[C@@]4(C)CC[C@@H]3[C@@]2(C)C[C@H]1C CHEMBL2104408 1 CC(C)[C@@H]1OC(=O)C2(/C=C/c3ccc4ccc(nc4c3)[C@@H](C)NC(=O)[C@@H]3CCCN(N3)C(=O)[C@H](C)NC1=O)CCS(=O)(=O)CC2 CHEMBL4175329 1 CC(=O)O[C@H]1CCC[C@@H]2COC(=O)[C@@H]21 CHEMBL2228334 1 CNC(=O)O[C@H]1OC(=O)[C@H]2[C@H]3C=C[C@H](C3)[C@H]21 CHEMBL3989617 1 CC1(C)CC[C@]2(C)CC[C@]3(C(=O)O)C(=CC[C@@H]4[C@@]5(C)CC[C@H](O)C(C)(C)[C@@H]5CC[C@]43C)[C@@H]2C1 CHEMBL559587 1 CC1(C)[C@@H](O)CC[C@]2(C)C3=C(CC[C@@H]12)[C@@]1(C)CC[C@@]2(C)CC[C@@](C)(CO)C[C@H]2[C@]1(C)CC3 CHEMBL484238 1 C[C@]12CC[C@H](c3cc(F)c(O)cc3F)C[C@H]1CC[C@@H]2O CHEMBL1651144 1 Cc1cncc(C2=CC=C3[C@@H]4CCC5CNC(=O)CC[C@]5(C)[C@H]4CC[C@]23C)c1 CHEMBL3938064 1 C[C@H](O)[C@H]1O[C@@H]2SC(N3CCCC3)=N[C@@H]2[C@@H](O)[C@@H]1O CHEMBL3647379 1 . Run the experiments . Now we read those molecules back in and then start collecting data. . Here are the different experiments: . Generate a single conformer for each molecule. | Try to generate 50 conformers for each molecule. | Try to generate 50 diverse conformers for each molecule using an RMSD filter of 0.5 | Try to generate 50 conformers for each molecule ignoring stereochemistry | We will use ETKDGv3 and repeat each run once starting from standard embedding and once starting from random coordinates. . suppl = Chem.SmilesMolSupplier(&#39;../data/chembl27_confgen_tgts.txt&#39;) ms = [Chem.AddHs(m) for m in suppl] . from rdkit.Chem import AllChem from collections import defaultdict import time import pickle . Single conformer . ps = AllChem.ETKDGv3() ps.randomSeed=0xf00d metric_etkdg_res = [] for i,m in enumerate(ms): if not (i+1)%10: print(f&#39;Doing {i+1} of {len(ms)}&#39;) m = Chem.Mol(m) t1 = time.time() AllChem.EmbedMolecule(m,ps) t2 = time.time() metric_etkdg_res.append((t2-t1,m.GetNumConformers(),m,m.GetIntProp(&#39;RTB&#39;))) with open(&#39;./results/random_coords_expt.pkl&#39;,&#39;wb+&#39;) as outf: pickle.dump((metric_etkdg_res,),outf) . ps = AllChem.ETKDGv3() ps.randomSeed=0xf00d ps.useRandomCoords = True random_etkdg_res = [] for i,m in enumerate(ms): if not (i+1)%10: print(f&#39;Doing {i+1} of {len(ms)}&#39;) m = Chem.Mol(m) t1 = time.time() AllChem.EmbedMolecule(m,ps) t2 = time.time() random_etkdg_res.append((t2-t1,m.GetNumConformers(),m,m.GetIntProp(&#39;RTB&#39;))) with open(&#39;./results/random_coords_expt.pkl&#39;,&#39;wb+&#39;) as outf: pickle.dump((metric_etkdg_res,random_etkdg_res,),outf) . 50 conformers . ps = AllChem.ETKDGv3() ps.randomSeed=0xf00d ps.numThreads = 4 metric_etkdg50_res = [] for i,m in enumerate(ms): if not (i+1)%10: print(f&#39;Doing {i+1} of {len(ms)}&#39;) m = Chem.Mol(m) t1 = time.time() AllChem.EmbedMultipleConfs(m,50,ps) t2 = time.time() metric_etkdg50_res.append((t2-t1,m.GetNumConformers(),m,m.GetIntProp(&#39;RTB&#39;))) with open(&#39;./results/random_coords_expt.pkl&#39;,&#39;wb+&#39;) as outf: pickle.dump((metric_etkdg_res,random_etkdg_res,metric_etkdg50_res,),outf) . ps = AllChem.ETKDGv3() ps.randomSeed=0xf00d ps.numThreads = 4 ps.useRandomCoords = True random_etkdg50_res = [] for i,m in enumerate(ms): if not (i+1)%10: print(f&#39;Doing {i+1} of {len(ms)}&#39;) m = Chem.Mol(m) t1 = time.time() AllChem.EmbedMultipleConfs(m,50,ps) t2 = time.time() random_etkdg50_res.append((t2-t1,m.GetNumConformers(),m,m.GetIntProp(&#39;RTB&#39;))) with open(&#39;./results/random_coords_expt.pkl&#39;,&#39;wb+&#39;) as outf: pickle.dump((metric_etkdg_res,random_etkdg_res,metric_etkdg50_res,random_etkdg50_res,),outf) . Include RMS Pruning . ps = AllChem.ETKDGv3() ps.randomSeed=0xf00d ps.numThreads = 4 ps.pruneRmsThresh = 0.5 metric_etkdg50_rms_res = [] for i,m in enumerate(ms): if not (i+1)%10: print(f&#39;Doing {i+1} of {len(ms)}&#39;) m = Chem.Mol(m) t1 = time.time() AllChem.EmbedMultipleConfs(m,50,ps) t2 = time.time() metric_etkdg50_rms_res.append((t2-t1,m.GetNumConformers(),m,m.GetIntProp(&#39;RTB&#39;))) with open(&#39;./results/random_coords_expt.pkl&#39;,&#39;wb+&#39;) as outf: pickle.dump((metric_etkdg_res,random_etkdg_res,metric_etkdg50_res,random_etkdg50_res, metric_etkdg50_rms_res,),outf) . ps = AllChem.ETKDGv3() ps.randomSeed=0xf00d ps.numThreads = 4 ps.useRandomCoords = True ps.pruneRmsThresh = 0.5 random_etkdg50_rms_res = [] for i,m in enumerate(ms): if not (i+1)%10: print(f&#39;Doing {i+1} of {len(ms)}&#39;) m = Chem.Mol(m) t1 = time.time() AllChem.EmbedMultipleConfs(m,50,ps) t2 = time.time() random_etkdg50_rms_res.append((t2-t1,m.GetNumConformers(),m,m.GetIntProp(&#39;RTB&#39;))) with open(&#39;./results/random_coords_expt.pkl&#39;,&#39;wb+&#39;) as outf: pickle.dump((metric_etkdg_res,random_etkdg_res,metric_etkdg50_res,random_etkdg50_res, metric_etkdg50_rms_res,random_etkdg50_rms_res),outf) . ps = AllChem.ETKDGv3() ps.randomSeed=0xf00d ps.numThreads = 4 ps.enforceChirality = False metric_etkdg50_nochiral_res = [] for i,m in enumerate(ms): if not (i+1)%10: print(f&#39;Doing {i+1} of {len(ms)}&#39;) m = Chem.Mol(m) t1 = time.time() AllChem.EmbedMultipleConfs(m,50,ps) t2 = time.time() metric_etkdg50_nochiral_res.append((t2-t1,m.GetNumConformers(),m,m.GetIntProp(&#39;RTB&#39;))) with open(&#39;./results/random_coords_expt.pkl&#39;,&#39;wb+&#39;) as outf: pickle.dump((metric_etkdg_res,random_etkdg_res,metric_etkdg50_res,random_etkdg50_res, metric_etkdg50_rms_res,random_etkdg50_rms_res,metric_etkdg50_nochiral_res,),outf) . ps = AllChem.ETKDGv3() ps.randomSeed=0xf00d ps.numThreads = 4 ps.useRandomCoords = True ps.enforceChirality = False random_etkdg50_nochiral_res = [] for i,m in enumerate(ms): if not (i+1)%10: print(f&#39;Doing {i+1} of {len(ms)}&#39;) m = Chem.Mol(m) t1 = time.time() AllChem.EmbedMultipleConfs(m,50,ps) t2 = time.time() random_etkdg50_nochiral_res.append((t2-t1,m.GetNumConformers(),m,m.GetIntProp(&#39;RTB&#39;))) with open(&#39;./results/random_coords_expt.pkl&#39;,&#39;wb+&#39;) as outf: pickle.dump((metric_etkdg_res,random_etkdg_res,metric_etkdg50_res,random_etkdg50_res, metric_etkdg50_rms_res,random_etkdg50_rms_res,metric_etkdg50_nochiral_res, random_etkdg50_nochiral_res),outf) . ps = AllChem.ETKDGv3() ps.randomSeed=0xf00d ps.numThreads = 4 ps.useRandomCoords = True ps.boxSizeMult = 1.0 random_etkdg50_box1_res = [] for i,m in enumerate(ms): if not (i+1)%10: print(f&#39;Doing {i+1} of {len(ms)}&#39;) m = Chem.Mol(m) t1 = time.time() AllChem.EmbedMultipleConfs(m,50,ps) t2 = time.time() random_etkdg50_box1_res.append((t2-t1,m.GetNumConformers(),m,m.GetIntProp(&#39;RTB&#39;))) with open(&#39;./results/random_coords_expt.pkl&#39;,&#39;wb+&#39;) as outf: pickle.dump((metric_etkdg_res,random_etkdg_res,metric_etkdg50_res,random_etkdg50_res, metric_etkdg50_rms_res,random_etkdg50_rms_res,metric_etkdg50_nochiral_res, random_etkdg50_nochiral_res, random_etkdg50_box1_res),outf) . ps = AllChem.ETKDGv3() ps.randomSeed=0xf00d ps.numThreads = 4 ps.useRandomCoords = True ps.boxSizeMult = 0.5 random_etkdg50_box2_res = [] for i,m in enumerate(ms): if not (i+1)%10: print(f&#39;Doing {i+1} of {len(ms)}&#39;) m = Chem.Mol(m) t1 = time.time() AllChem.EmbedMultipleConfs(m,50,ps) t2 = time.time() random_etkdg50_box2_res.append((t2-t1,m.GetNumConformers(),m,m.GetIntProp(&#39;RTB&#39;))) with open(&#39;./results/random_coords_expt.pkl&#39;,&#39;wb+&#39;) as outf: pickle.dump((metric_etkdg_res,random_etkdg_res,metric_etkdg50_res,random_etkdg50_res, metric_etkdg50_rms_res,random_etkdg50_rms_res,metric_etkdg50_nochiral_res, random_etkdg50_nochiral_res, random_etkdg50_box1_res, random_etkdg50_box2_res),outf) . Do the Analysis . figsize(15,6) nrots = sorted(set(x[-1] for x in metric_etkdg_res)) subplot(1,2,1) for nrot in nrots: xp = [x[0] for x in metric_etkdg_res if x[-1]==nrot] yp = [x[0] for x in random_etkdg_res if x[-1]==nrot] scatter(xp,yp,label=str(nrot)) legend(); xlim(0,3.5); ylim(0,4); plot((0,4),(0,4)) xlabel(&#39;metric&#39;) ylabel(&#39;random coords&#39;); title(&#39;zoom&#39;); subplot(1,2,2) for nrot in nrots: xp = [x[0] for x in metric_etkdg_res if x[-1]==nrot] yp = [x[0] for x in random_etkdg_res if x[-1]==nrot] scatter(xp,yp,label=str(nrot)) legend(); xlabel(&#39;metric&#39;) ylabel(&#39;random coords&#39;); title(&#39;full range&#39;); . figsize(15,6) nrots = sorted(set(x[-1] for x in metric_etkdg_res)) subplot(1,2,1) for nrot in nrots: xp = [x[0] for x in metric_etkdg50_res if x[-1]==nrot] yp = [x[0] for x in random_etkdg50_res if x[-1]==nrot] scatter(xp,yp,label=str(nrot)) legend(); xlim(0,50); ylim(0,80); plot((0,35),(0,35)) title(&#39;time (s)&#39;) xlabel(&#39;metric&#39;) ylabel(&#39;random coords&#39;); title(&#39;zoom&#39;); subplot(1,2,2) for nrot in nrots: xp = [x[0] for x in metric_etkdg50_res if x[-1]==nrot] yp = [x[0] for x in random_etkdg50_res if x[-1]==nrot] scatter(xp,yp,label=str(nrot)) legend(); #xlim(0,25); #ylim(0,35); plot((0,500),(0,500)) title(&#39;time (s)&#39;) xlabel(&#39;metric&#39;) ylabel(&#39;random coords&#39;); title(&#39;full range&#39;); . Number of conformers generated . figsize(7.5,6) nrots = sorted(set(x[-1] for x in metric_etkdg_res)) print(f&#39;number of mols with below 50 conformers:&#39;) for nrot in nrots: xp = [x[1] for x in metric_etkdg50_res if x[-1]==nrot] yp = [x[1] for x in random_etkdg50_res if x[-1]==nrot] print(f&#39; {nrot} rotatable bonds, metric: {len([1 for x in xp if x!=50])} random: {len([1 for x in yp if x!=50])}&#39;) scatter(xp,yp,label=str(nrot)) legend(); #xlim(0,30); #ylim(0,40); #plot((0,30),(0,30)) title(&#39;num confs generated out of 50&#39;) xlabel(&#39;metric&#39;) ylabel(&#39;random coords&#39;); . number of mols with below 50 conformers: -14 rotatable bonds, metric: 8 random: 0 -10 rotatable bonds, metric: 1 random: 1 1 rotatable bonds, metric: 2 random: 2 2 rotatable bonds, metric: 2 random: 2 5 rotatable bonds, metric: 1 random: 1 10 rotatable bonds, metric: 4 random: 0 15 rotatable bonds, metric: 10 random: 0 20 rotatable bonds, metric: 27 random: 0 25 rotatable bonds, metric: 28 random: 0 . figsize(7.5,6) nrots = sorted(set(x[-1] for x in metric_etkdg_res)) print(f&#39;number of mols with below 50 conformers:&#39;) for nrot in nrots: xp = [x[1] for x in metric_etkdg50_rms_res if x[-1]==nrot] yp = [x[1] for x in random_etkdg50_rms_res if x[-1]==nrot] print(f&#39; {nrot} rotatable bonds, metric: {len([1 for x in xp if x!=50])} random: {len([1 for x in yp if x!=50])}&#39;) scatter(xp,yp,label=str(nrot)) legend(); #xlim(0,30); #ylim(0,40); plot((0,50),(0,50)) title(&#39;num diverse confs generated out of 50&#39;) xlabel(&#39;metric&#39;) ylabel(&#39;random coords&#39;); . number of mols with below 50 conformers: -14 rotatable bonds, metric: 31 random: 17 -10 rotatable bonds, metric: 85 random: 83 1 rotatable bonds, metric: 99 random: 99 2 rotatable bonds, metric: 100 random: 100 5 rotatable bonds, metric: 93 random: 85 10 rotatable bonds, metric: 32 random: 19 15 rotatable bonds, metric: 13 random: 1 20 rotatable bonds, metric: 27 random: 0 25 rotatable bonds, metric: 28 random: 0 . figsize(7.5,6) nrots = sorted(set(x[-1] for x in metric_etkdg_res)) print(f&#39;number of mols with below 50 conformers:&#39;) for nrot in nrots: xp = [x[1] for x in metric_etkdg50_nochiral_res if x[-1]==nrot] yp = [x[1] for x in random_etkdg50_nochiral_res if x[-1]==nrot] print(f&#39; {nrot} rotatable bonds, metric: {len([1 for x in xp if x!=50])} random: {len([1 for x in yp if x!=50])}&#39;) scatter(xp,yp,label=str(nrot)) legend(); #xlim(0,30); #ylim(0,40); #plot((0,30),(0,30)) title(&#39;num nochiral confs generated out of 50&#39;) xlabel(&#39;metric&#39;) ylabel(&#39;random coords&#39;); . number of mols with below 50 conformers: -14 rotatable bonds, metric: 6 random: 0 -10 rotatable bonds, metric: 0 random: 0 1 rotatable bonds, metric: 0 random: 0 2 rotatable bonds, metric: 0 random: 0 5 rotatable bonds, metric: 0 random: 0 10 rotatable bonds, metric: 2 random: 0 15 rotatable bonds, metric: 9 random: 0 20 rotatable bonds, metric: 26 random: 0 25 rotatable bonds, metric: 21 random: 0 . The random coordinate embedding produces 50 conformers in almost every case, while there are a significant number of examples where metric embedding is unable to produce all 50 conformers. . Time per conformer generated . figsize(15,6) nrots = sorted(set(x[-1] for x in metric_etkdg_res)) subplot(1,2,1) for nrot in nrots: keep = [i for i,(x,y) in enumerate(zip(metric_etkdg50_res,random_etkdg50_res)) if x[-1]==nrot and x[1]!=0 and y[1]!=0] xp = [metric_etkdg50_res[x][0]/metric_etkdg50_res[x][1] for x in keep] yp = [random_etkdg50_res[x][0]/random_etkdg50_res[x][1] for x in keep] scatter(xp,yp,label=str(nrot)) legend(); xlim(0,1.5); ylim(0,1.2); plot((0,.8),(0,.8)) title(&#39;time per conformer produced (4 threads)&#39;) xlabel(&#39;metric&#39;) ylabel(&#39;random coords&#39;); subplot(1,2,2) for nrot in nrots: keep = [i for i,(x,y) in enumerate(zip(metric_etkdg50_rms_res,random_etkdg50_rms_res)) if x[-1]==nrot and x[1]!=0 and y[1]!=0] xp = [metric_etkdg50_res[x][0]/metric_etkdg50_rms_res[x][1] for x in keep] yp = [random_etkdg50_res[x][0]/random_etkdg50_rms_res[x][1] for x in keep] scatter(xp,yp,label=str(nrot)) legend(); xlim(0,1.5); ylim(0,2); plot((0,1),(0,1)) title(&#39;time per diverse conformer produced (4 threads)&#39;) xlabel(&#39;metric&#39;) ylabel(&#39;random coords&#39;); . Look at the same thing without cropping outliers. . figsize(15,6) nrots = sorted(set(x[-1] for x in metric_etkdg_res)) subplot(1,2,1) for nrot in nrots: keep = [i for i,(x,y) in enumerate(zip(metric_etkdg50_res,random_etkdg50_res)) if x[-1]==nrot and x[1]!=0 and y[1]!=0] xp = [metric_etkdg50_res[x][0]/metric_etkdg50_res[x][1] for x in keep] yp = [random_etkdg50_res[x][0]/random_etkdg50_res[x][1] for x in keep] scatter(xp,yp,label=str(nrot)) legend(); plot((0,3.5),(0,3.5)) title(&#39;time per conformer produced (4 threads)&#39;) xlabel(&#39;metric&#39;) ylabel(&#39;random coords&#39;); subplot(1,2,2) for nrot in nrots: keep = [i for i,(x,y) in enumerate(zip(metric_etkdg50_rms_res,random_etkdg50_rms_res)) if x[-1]==nrot and x[1]!=0 and y[1]!=0] xp = [metric_etkdg50_res[x][0]/metric_etkdg50_rms_res[x][1] for x in keep] yp = [random_etkdg50_res[x][0]/random_etkdg50_rms_res[x][1] for x in keep] scatter(xp,yp,label=str(nrot)) legend(); plot((0,3.5),(0,3.5)) title(&#39;time per diverse conformer produced (4 threads)&#39;) xlabel(&#39;metric&#39;) ylabel(&#39;random coords&#39;); . Note that these times per conformer cannot be directly compared to the time to generate a single conformer since these were run using multiple threads. . Ignoring chirality . figsize(7.5,6) nrots = sorted(set(x[-1] for x in metric_etkdg_res)) for nrot in nrots: xp = [x[0] for x in metric_etkdg50_nochiral_res if x[-1]==nrot] yp = [x[0] for x in random_etkdg50_nochiral_res if x[-1]==nrot] scatter(xp,yp,label=str(nrot)) legend(); #xlim(0,30); #ylim(0,40); plot((0,15),(0,15)) title(&#39;nochiral time(s)&#39;) xlabel(&#39;metric&#39;) ylabel(&#39;random coords&#39;); . General impact of ignoring chirality . nrots = sorted(set(x[-1] for x in metric_etkdg_res)) figsize(15,6) subplot(1,2,1) for nrot in nrots: xp = [x[0] for x in metric_etkdg50_res if x[-1]==nrot] yp = [x[0] for x in metric_etkdg50_nochiral_res if x[-1]==nrot] scatter(xp,yp,label=str(nrot)) legend(); xlim(0,50); ylim(0,30); plot((0,30),(0,30)) title(&#39;metric embedding time(s)&#39;) xlabel(&#39;chiral&#39;) ylabel(&#39;nochiral&#39;); subplot(1,2,2) for nrot in nrots: xp = [x[0] for x in random_etkdg50_res if x[-1]==nrot] yp = [x[0] for x in random_etkdg50_nochiral_res if x[-1]==nrot] scatter(xp,yp,label=str(nrot)) legend(); xlim(0,50); ylim(0,40); plot((0,40),(0,40)) title(&#39;random embedding time(s)&#39;) xlabel(&#39;chiral&#39;) ylabel(&#39;nochiral&#39;); . Impact of box size on random embedding . nrots = sorted(set(x[-1] for x in metric_etkdg_res)) figsize(15,6) subplot(1,2,1) for nrot in nrots: xp = [x[0] for x in random_etkdg50_res if x[-1]==nrot] yp = [x[0] for x in random_etkdg50_box1_res if x[-1]==nrot] scatter(xp,yp,label=str(nrot)) legend(); xlim(0,80); ylim(0,80); plot((0,60),(0,60)) title(&#39;random embedding time(s)&#39;) xlabel(&#39;mult=2 (default)&#39;) ylabel(&#39;mult=1&#39;); subplot(1,2,2) for nrot in nrots: xp = [x[0] for x in random_etkdg50_res if x[-1]==nrot] yp = [x[0] for x in random_etkdg50_box2_res if x[-1]==nrot] scatter(xp,yp,label=str(nrot)) legend(); xlim(0,80); ylim(0,80); plot((0,60),(0,60)) title(&#39;random embedding time(s)&#39;) xlabel(&#39;mult=2 (default)&#39;) ylabel(&#39;mult=0.5&#39;); . Summaries . def set_box_color(bp, color): setp(bp[&#39;boxes&#39;], color=color) setp(bp[&#39;whiskers&#39;], color=color) setp(bp[&#39;caps&#39;], color=color) setp(bp[&#39;medians&#39;], color=color) setp(bp[&#39;fliers&#39;], markeredgecolor=color) figsize(15,6) ax = axes() ax.set_yscale(&#39;log&#39;); ax.set_ylabel(&#39;time(s)&#39;) ax.set_xlabel(&#39;nrot&#39;) nrots = sorted(set(x[-1] for x in metric_etkdg_res)) d = [[x[0] for x in metric_etkdg50_res if x[-1]==nrot] for nrot in nrots] bp = ax.boxplot(d,positions = [3*x for x in range(len(d))]); set_box_color(bp,&#39;r&#39;) d = [[x[0] for x in random_etkdg50_res if x[-1]==nrot] for nrot in nrots] bp = ax.boxplot(d,positions = [3*x+.5 for x in range(len(d))]); set_box_color(bp,&#39;b&#39;) d = [[x[0] for x in random_etkdg50_nochiral_res if x[-1]==nrot] for nrot in nrots] bp = ax.boxplot(d,positions = [3*x+1 for x in range(len(d))]); set_box_color(bp,&#39;c&#39;) d = [[x[0] for x in random_etkdg50_box1_res if x[-1]==nrot] for nrot in nrots] bp = ax.boxplot(d,positions = [3*x+1.5 for x in range(len(d))]); set_box_color(bp,&#39;m&#39;) d = [[x[0] for x in random_etkdg50_box2_res if x[-1]==nrot] for nrot in nrots] bp = ax.boxplot(d,positions = [3*x+2 for x in range(len(d))]); set_box_color(bp,&#39;y&#39;) #set_axis_style(ax, [str(x) for x in nrots]) ticks = [str(x) for x in nrots] xticks(np.arange(0, len(ticks) * 3, 3)+1, ticks); plot([], c=&#39;r&#39;, label=&#39;metric&#39;) plot([], c=&#39;b&#39;, label=&#39;random&#39;) plot([], c=&#39;c&#39;, label=&#39;random-nochiral&#39;) plot([], c=&#39;m&#39;, label=&#39;random-box1&#39;) plot([], c=&#39;y&#39;, label=&#39;random-box0.5&#39;) legend(); . def set_box_color(bp, color): setp(bp[&#39;boxes&#39;], color=color) setp(bp[&#39;whiskers&#39;], color=color) setp(bp[&#39;caps&#39;], color=color) setp(bp[&#39;medians&#39;], color=color) setp(bp[&#39;fliers&#39;], markeredgecolor=color) figsize(15,6) ax = axes() ax.set_yscale(&#39;log&#39;); ax.set_ylabel(&#39;time per conformer (s)&#39;) ax.set_xlabel(&#39;nrot&#39;) nrots = sorted(set(x[-1] for x in metric_etkdg_res)) d = [[x[0]/x[2].GetNumConformers() for x in metric_etkdg50_res if x[-1]==nrot and x[2].GetNumConformers()!=0] for nrot in nrots] bp = ax.boxplot(d,positions = [3*x for x in range(len(d))]); set_box_color(bp,&#39;r&#39;) d = [[x[0]/x[2].GetNumConformers() for x in metric_etkdg50_rms_res if x[-1]==nrot and x[2].GetNumConformers()!=0] for nrot in nrots] bp = ax.boxplot(d,positions = [3*x+.5 for x in range(len(d))]); set_box_color(bp,&#39;c&#39;) d = [[x[0]/x[2].GetNumConformers() for x in random_etkdg50_res if x[-1]==nrot and x[2].GetNumConformers()!=0] for nrot in nrots] bp = ax.boxplot(d,positions = [3*x+1 for x in range(len(d))]); set_box_color(bp,&#39;b&#39;) d = [[x[0]/x[2].GetNumConformers() for x in random_etkdg50_rms_res if x[-1]==nrot and x[2].GetNumConformers()!=0] for nrot in nrots] bp = ax.boxplot(d,positions = [3*x+1.5 for x in range(len(d))]); set_box_color(bp,&#39;m&#39;) #set_axis_style(ax, [str(x) for x in nrots]) ticks = [str(x) for x in nrots] xticks(np.arange(0, len(ticks) * 3, 3)+1, ticks); plot([], c=&#39;r&#39;, label=&#39;metric&#39;) plot([], c=&#39;c&#39;, label=&#39;metric-diverse&#39;) plot([], c=&#39;b&#39;, label=&#39;random&#39;) plot([], c=&#39;m&#39;, label=&#39;random-diverse&#39;) legend(); . Look at some of the troublesome structures . Which ones couldn&#39;t we generate conformers for? . no_confs_metric_etkdg50 = set([i for i,x in enumerate(metric_etkdg50_res) if x[2].GetNumConformers()==0]) no_confs_random_etkdg50 = set([i for i,x in enumerate(metric_etkdg50_res) if x[2].GetNumConformers()==0]) print(f&#39;metric: {len(no_confs_metric_etkdg50)}, random embedding: {len(no_confs_random_etkdg50)}, overlap: {len(no_confs_metric_etkdg50.union(no_confs_random_etkdg50))}&#39;) . metric: 13, random embedding: 13, overlap: 13 . dms = [Chem.RemoveHs(ms[i]) for i in no_confs_metric_etkdg50] dms = [m for m in dms if m.GetNumAtoms()&lt;75] Draw.MolsToGridImage(dms,subImgSize=(300,250),molsPerRow=3, legends=[m.GetProp(&#39;_Name&#39;) for m in dms]) . dms = [Chem.RemoveHs(ms[i]) for i in no_confs_metric_etkdg50] dms = [m for m in dms if m.GetNumAtoms()&gt;=75] from IPython.display import SVG d2d = Draw.MolDraw2DSVG(800,350) d2d.DrawMolecule(dms[0]) d2d.FinishDrawing() SVG(d2d.GetDrawingText()) . Ok, some of those are quite constrained and have a fair number of chiral centers, so it&#39;s easy to imagine them being hard to embed. Some (like CHEMBL59404) are just peptides though... seems like those should be manageable. Something to look into . What about the structures which embed but take a really long time? . slow_metric_etkdg50 = [y for x,y in sorted([(x[0],i) for i,x in enumerate(metric_etkdg50_res) if x[2].GetNumConformers()],reverse=True)][:5] dms = [Chem.RemoveHs(ms[i]) for i in slow_metric_etkdg50] #dms = [m for m in dms if m.GetNumAtoms()&lt;75] Draw.MolsToGridImage(dms,subImgSize=(300,250),molsPerRow=3, legends=[m.GetProp(&#39;_Name&#39;) for m in dms]) . IPythonConsole.ipython_3d = True metric_etkdg50_res[slow_metric_etkdg50[0]][2] . You appear to be running in JupyterLab (or JavaScript failed to load for some other reason). You need to install the 3dmol extension: jupyter labextension install jupyterlab_3dmol . metric_etkdg50_res[slow_metric_etkdg50[4]][2] . You appear to be running in JupyterLab (or JavaScript failed to load for some other reason). You need to install the 3dmol extension: jupyter labextension install jupyterlab_3dmol .",
            "url": "https://greglandrum.github.io/rdkit-blog/conformers/exploration/2021/01/31/looking-at-random-coordinate-embedding.html",
            "relUrl": "/conformers/exploration/2021/01/31/looking-at-random-coordinate-embedding.html",
            "date": " • Jan 31, 2021"
        }
        
    
  
    
        ,"post4": {
            "title": "Sphere exclusion clustering with the RDKit",
            "content": "Roger Sayle contributed an implementation of sphere-exclusion picking to the RDKit as part of the 2019.09 release and I recently realized that I&#39;d never blogged about that code or how to use it to do compound clustering. So here&#39;s a short(ish) one. . The RDKit has had an implementation of the MaxMin algorithm for picking diverse compounds for quite a while (Roger made this a lot faster back in 2017). The input to the MaxMin picker is the number of diverse compounds you want. The new algorithm is different: you provide the minimum distance allowed between the compounds picked and it returns a set of compounds satisfying that constraint. . Both of these methods for picking diverse compounds can then be converted into clustering algorithms by defining those picked points to be cluster centroids and then assigning non-picked compounds to the nearest centroid. We&#39;ll do that here for the sphere-exclusion algorithm. . Further reading: . for more about the sphere-exclusion picker and/or learn how it works: here&#39;s Roger&#39;s UGM presentation | Roger&#39;s UGM presentation describing his fast implementation of the MaxMin picker is here | Tim Dudgeon&#39;s guest post on this blog provides a nice overview of the new MaxMin picker. | . from rdkit import Chem from rdkit import DataStructs from rdkit.Chem import Draw from rdkit.Chem.Draw import IPythonConsole from rdkit.Chem import rdDepictor, rdMolDescriptors import time rdDepictor.SetPreferCoordGen(True) import rdkit %pylab inline print(rdkit.__version__) . Populating the interactive namespace from numpy and matplotlib 2020.09.1 . First dataset . The dataset we&#39;ll start with is the &quot;new Lessel and Briem&quot; set that I put together as part of this blog post . ms = [x for x in Chem.SmilesMolSupplier(&#39;../data/BLSets_selected_actives.txt&#39;)] len(ms) . 6359 . We&#39;ll use MFP2 fingerprints: . from rdkit.Chem import rdMolDescriptors fps = [rdMolDescriptors.GetMorganFingerprintAsBitVect(m,2,2048) for m in ms] . The new sphere-exclusion code is available using the LeaderPicker: . from rdkit.SimDivFilters import rdSimDivPickers lp = rdSimDivPickers.LeaderPicker() . And we pick compounds by giving the picker the fingerprints and a minimum distance between cluster centroids. Here we&#39;re using a distance threshold of 0.65, which is the random-similarity threshold I found for MFP2 fingeprints. . thresh = 0.65 # &lt;- minimum distance between cluster centroids picks = lp.LazyBitVectorPick(fps,len(fps),thresh) print(len(picks)) . 535 . For reference, here&#39;s how long that takes to run: . %timeit lp.LazyBitVectorPick(fps,len(fps),thresh) . 41.9 ms ± 262 µs per loop (mean ± std. dev. of 7 runs, 10 loops each) . Let&#39;s look at some of those picked compounds: . Draw.MolsToGridImage([ms[x] for x in picks[:12]],molsPerRow=4) . Just to get a feeling for what&#39;s going on, calculate the similarities between the compounds that have been picked. . from rdkit import DataStructs pickfps = [fps[x] for x in picks] nearest = [] simhist = [] for i,fpi in enumerate(pickfps): tfps = pickfps[:] del tfps[i] sims = DataStructs.BulkTanimotoSimilarity(fpi,tfps) nearest.append(max(sims)) simhist.extend(sims) sorted(nearest,reverse=True)[:10] . [0.3492063492063492, 0.3492063492063492, 0.3492063492063492, 0.3492063492063492, 0.3488372093023256, 0.3488372093023256, 0.3488372093023256, 0.3488372093023256, 0.3488372093023256, 0.3488372093023256] . Remember that we defined a distance threshold of 0.65, so there should be no similarity values above 0.35 here. It&#39;s good to see that this is true. . Here&#39;s the histogram of distances . hist(simhist,bins=20); xlabel(&#39;similarity&#39;); . Now let&#39;s assign points to clusters. As mentioned above, we do that by defining the picked compounds to be the centroids and then assign each other compound in the dataset to the nearest cluster centroid. . We don&#39;t currently have a single call for doing this, so here&#39;s a Python function: . from collections import defaultdict import numpy as np def assignPointsToClusters(picks,fps): clusters = defaultdict(list) for i,idx in enumerate(picks): clusters[i].append(idx) sims = np.zeros((len(picks),len(fps))) for i in range(len(picks)): pick = picks[i] sims[i,:] = DataStructs.BulkTanimotoSimilarity(fps[pick],fps) sims[i,i] = 0 best = np.argmax(sims,axis=0) for i,idx in enumerate(best): if i not in picks: clusters[idx].append(i) return clusters . clusters = assignPointsToClusters(picks,fps) hist([len(clusters[x]) for x in clusters]); xlabel(&#39;cluster size&#39;); . hist([len(clusters[x]) for x in clusters],log=True); xlabel(&#39;cluster size&#39;); . Unfortunately this implementation for assigning compounds to clusters isn&#39;t particularly efficient since it makes a bunch of calls across the Python/C++ interface: . %timeit assignPointsToClusters(picks,fps) . 360 ms ± 10.5 ms per loop (mean ± std. dev. of 7 runs, 1 loop each) . I hope to have the chance to improve the performance of this step in a future RDKit release. . Looking at the clusters . Let&#39;s look at the compounds inside a couple of clusters in order to see how closely related they seem to be: . clusts12 = [x for x in clusters if len(clusters[x])==12] len(clusts12) . 10 . Draw.MolsToGridImage([ms[x] for x in clusters[clusts12[0]]],molsPerRow=4) . We can also look at the intra-cluster similarities . def intracluster_similarities(cluster,fps): res = [] cfps = [fps[x] for x in cluster] for i,fpid in enumerate(cluster): tres = DataStructs.BulkTanimotoSimilarity(cfps[i],cfps) del tres[i] res.extend(tres) return res . hist(intracluster_similarities(clusters[clusts12[0]],fps)); xlabel(&#39;Similarity&#39;); . Draw.MolsToGridImage([ms[x] for x in clusters[clusts12[1]]],molsPerRow=4) . hist(intracluster_similarities(clusters[clusts12[1]],fps)); xlabel(&#39;Similarity&#39;); . Both clusters are clearly include related compounds . Decreasing the sphere radius . What about if we make the clusters tighter by decreasing the threshold distance? . thresh = 0.35 # &lt;- minimum distance between cluster centroids picks = lp.LazyBitVectorPick(fps,len(fps),thresh) print(len(picks)) . 1832 . clusters = assignPointsToClusters(picks,fps) hist([len(clusters[x]) for x in clusters]); xlabel(&#39;cluster size&#39;); . We&#39;ve got more clusters and they are smaller. No big surprise . And let&#39;s look at a couple of those . clusts12 = [x for x in clusters if len(clusters[x])==12] len(clusts12) . 17 . Draw.MolsToGridImage([ms[x] for x in clusters[clusts12[0]]],molsPerRow=4) . hist(intracluster_similarities(clusters[clusts12[0]],fps)); xlabel(&#39;Similarity&#39;); . Draw.MolsToGridImage([ms[x] for x in clusters[clusts12[1]]],molsPerRow=4) . hist(intracluster_similarities(clusters[clusts12[1]],fps)); xlabel(&#39;Similarity&#39;); . Again, those mostly look quite similar to each other, maybe even more similar than before? . Impact of sphere radius on the number of clusters . Look at the number of clusters as a function of the threshold . results = [] for thresh in arange(0.65,0.05,-0.05): tpicks = lp.LazyBitVectorPick(fps,len(fps),thresh) results.append([thresh,len(tpicks)]) . scatter([x for x,y in results],[y for x,y in results]); ylabel(&#39;number of clusters&#39;) xlabel(&#39;distance threshold&#39;) . Text(0.5, 0, &#39;distance threshold&#39;) . Trying a larger dataset . I said that Roger&#39;s implementation was efficient, but the dataset above wasn&#39;t all that big. Let&#39;s try a larger one. . Here we&#39;ll use the full set of compounds I grabbed data for when building the new &quot;Lessel and Briem&quot; datasets. . As an aside, this is also a nice opportunity to demonstrate using the MultithreadedSmilesMolSupplier that Shrey Aryan added to the RDKit as part of his 2020 Google Summer of Code project. This new supplier allows molecules to be constructed in parallel and can, in some situations, really speed things up. . t1 = time.time() fps = [rdMolDescriptors.GetMorganFingerprintAsBitVect(m,2,2048) for m in Chem.MultithreadedSmilesMolSupplier(&#39;../data/BLSets_actives.txt&#39;,numWriterThreads=4,delimiter=&#39; t&#39;) if m is not None] t2 = time.time() print(f&quot;That took {t2-t1 :.2f} seconds to build {len(fps)} fingerprints&quot;) . That took 6.02 seconds to build 91663 fingerprints . Running that single threaded (i.e. using a normal SmilesMolSupplier) took 16.8 seconds on my machine. . Pick the cluster centroids: . lp = rdSimDivPickers.LeaderPicker() thresh = 0.65 # &lt;- minimum distance between cluster centroids picks = lp.LazyBitVectorPick(fps,len(fps),thresh) print(len(picks)) . 2997 . How long does that take? . %timeit lp.LazyBitVectorPick(fps,len(fps),thresh) . 5.14 s ± 320 ms per loop (mean ± std. dev. of 7 runs, 1 loop each) . t1 = time.time() clusters = assignPointsToClusters(picks,fps) t2=time.time() print(f&quot;That took {t2-t1 :.2f} seconds&quot;) hist([len(clusters[x]) for x in clusters]); xlabel(&#39;cluster size&#39;); . That took 43.34 seconds . And, finally, look at the number of clusters and clustering time as a function of the sphere radius . results = [] for thresh in (0.2,0.3,0.4,0.5,0.6,0.7,0.8): lp = rdSimDivPickers.LeaderPicker() t1 = time.time() picks = lp.LazyBitVectorPick(fps,len(fps),thresh) t2 = time.time() print(f&quot;distance threshold {thresh: .2f}, {len(picks)} clusters in {t2-t1 :.2f} seconds&quot;) results.append((thresh,len(picks),t2-t1)) . distance threshold 0.20, 34535 clusters in 66.25 seconds distance threshold 0.30, 20627 clusters in 37.51 seconds distance threshold 0.40, 11799 clusters in 21.47 seconds distance threshold 0.50, 6811 clusters in 12.48 seconds distance threshold 0.60, 4047 clusters in 7.02 seconds distance threshold 0.70, 2021 clusters in 3.07 seconds distance threshold 0.80, 558 clusters in 0.51 seconds . Those two track nicely with each other; more clusters = longer run time: . fig, ax = subplots() ax.plot([x[0] for x in results],[x[1] for x in results]); ax.set_xlabel(&#39;Sphere radius&#39;); ax.set_ylabel(&#39;Num clusters&#39;); ax2 = ax.twinx() ax2.plot([x[0] for x in results],[x[2] for x in results],c=&#39;r&#39;); ax2.set_ylabel(&#39;Time (s)&#39;); .",
            "url": "https://greglandrum.github.io/rdkit-blog/similarity/tutorial/2020/11/18/sphere-exclusion-clustering.html",
            "relUrl": "/similarity/tutorial/2020/11/18/sphere-exclusion-clustering.html",
            "date": " • Nov 18, 2020"
        }
        
    
  
    
        ,"post5": {
            "title": "Setting up an environment to make Python contributions to the RDKit",
            "content": "It has been tricky to contribute code or documentation to the RDKit if you’re a Python programmer who doesn’t want to deal with the complexities of getting an RDKit build working. We want to make it straightforward for people to contribute, so I’m working on some recipes to make thigs easier. This is the first pass at that. . In order to fix bugs or add features in Python you need to be able to clone a local fork of the RDKit from github, modify the code in that local clone, and then run the local code in order to test it. The problem is that most RDKit functionality requires some binary components that need to be built from C++ and installed in the appropriate places. We’re going to work around that problem here by copying the binary components from a recent binary distribution of the RDKit into a local clone of the RDKit repo. . I’m going to explain each of the required steps, but the complete set of steps required is at the bottom of this post. Assuming that you have the prerequisites (explained directly below), I hope that these will “just work” for you, but one never knows… I’d like to be able to include this in the RDKit documentation, so please me know how it goes if you try the recipe out. Please do not add a comment to this blog post, I’ve created a github issue so that we have the comments in one place. If you don’t have a github account, please email me your comments and I’ll add them to the issue. . The steps explained . At the moment this recipe only works on linux and the mac. I will put together a similar recipe for windows and either do a separate post or update this one. . Prerequisites: . you need to have either anaconda python or miniconda installed and in your path | you need to have git installed and in your path | . You should start by changing into the directory where you want to clone the RDKit source repository and then running: . git clone https://github.com/rdkit/rdkit.git . That will clone the repo from github into a local directory called rdkit. We now change into that directory and use it to set our RDBASE environment variable: . cd rdkit export RDBASE=`pwd` . The next step is to create the conda environment that we’re going to use to hold the RDKit binary components and install a recent beta version of the RDKit into that environment: . conda create -y -n py37_rdkit_beta python=3.7 conda activate py37_rdkit_beta conda install -y -c rdkit/label/beta rdkit . If you have other Python packages that you’d like to work with, go ahead and install them into the environment now. . Next we copy the RDKit binary components from that environment into our local clone of the RDKit repo: . cd $CONDA_PREFIX/lib/python3.7/site-packages/rdkit rsync -a -m --include &#39;*/&#39; --include=&#39;*.so&#39; --include=&#39;inchi.py&#39; --exclude=&#39;*&#39; . $RDBASE/rdkit . NOTE: that rsync command should be one long line. . Finally we set our PYTHONPATH and then test that everything is working by importing the RDKit’s Chem module: . export PYTHONPATH=&quot;$RDBASE&quot; cd $RDBASE/rdkit python -c &#39;from rdkit import Chem;print(Chem.__file__)&#39; . That last command should not generate errors and should show you a filename that is in your local github clone. As an example, I started the first step of this process in my /scratch/rdkit_devel directory, so I see: . /scratch/rdkit_devel/rdkit/rdkit/Chem/__init__.py . Running the tests . If you’re planning on making an RDKit contribution, it’s important to know how to run the Python tests to make sure that your changes work and don’t break anything else. For historic reasons the RDKit uses a self-written framework for running tests, but it’s easy enough to use. You need to run the script $RDBASE/rdkit/TestRunner.py and point it to the test_list.py file containing the tests to be run. For example, if you want to run all the tests in the directory $RDBASE/rdkit/Chem (this corresponds to the python module rdkit.Chem), you would do: . cd $RDBASE/rdkit/Chem python $RDBASE/rdkit/TestRunner.py test_list.py . That will take a while and generate a lot of output, including things that look like exceptions and errors, but should finish with something like: . Script: test_list.py. Passed 40 tests in 69.70 seconds . Finishing up . You’re set. The one thing to remember is that whenever you want to use this environment in a new terminal window or shell, you need to activate the py37_rdkit_beta conda environment (don’t delete it!), set RDBASE, and set your PYTHONPATH: . conda activate py37_rdkit_beta cd your_local_rdkit_clone # &lt;- replace this with the real name of the directory export RDBASE=`pwd` export PYTHONPATH=&quot;$RDBASE&quot; . The recipe . Here’s the complete recipe: . git clone https://github.com/rdkit/rdkit.git cd rdkit export RDBASE=`pwd` conda create -y -n py37_rdkit_beta python=3.7 conda activate py37_rdkit_beta conda install -y -c rdkit/label/beta rdkit cd $CONDA_PREFIX/lib/python3.7/site-packages/rdkit rsync -a -m --include &#39;*/&#39; --include=&#39;*.so&#39; --include=&#39;inchi.py&#39; --exclude=&#39;*&#39; . $RDBASE/rdkit export PYTHONPATH=&quot;$RDBASE&quot; cd $RDBASE/rdkit python -c &#39;from rdkit import Chem;print(Chem.__file__)&#39; .",
            "url": "https://greglandrum.github.io/rdkit-blog/contributing/tutorial/2020/03/30/setting-up-an-environment.html",
            "relUrl": "/contributing/tutorial/2020/03/30/setting-up-an-environment.html",
            "date": " • Mar 30, 2020"
        }
        
    
  
    
        ,"post6": {
            "title": "Finding regioisomers",
            "content": "This is one that came up recently on the mailing list that I thought made for a good example to demonstrate how to write Python to do some more advanced structural searches with the RDKit. . from rdkit import Chem from rdkit.Chem import Draw from rdkit.Chem.Draw import IPythonConsole import rdkit print(rdkit.__version__) . 2019.09.3 . RDKit WARNING: [05:43:19] Enabling RDKit 2019.09.3 jupyter extensions . My paraphrasing of the problem: Alexis wanted to be able to do the equivalent of a substructure search that finds all aromatic rings that have both Cl and Br substituents. So he wanted to be able to match the first two of these, but not the second: . ms = [Chem.MolFromSmiles(x) for x in &#39;Clc1c(Br)cccc1 Clc1cc(Br)ccc1 Clc1cccc2c1c(Br)ccc2&#39;.split()] Draw.MolsToGridImage(ms,legends=&#39;match match no-match&#39;.split()) . It&#39;s really non-trivial to do this with SMARTS since it has no way to express that two atoms should be in the same ring without making the ring explicit in the SMARTS. I was able to come up with this SMARTS, which works, but is unwieldy (at best): . p = Chem.MolFromSmarts(&#39;Cl[c;$(c1(Cl)c(Br)cccc1),$(c1(Cl)cc(Br)ccc1),$(c1(Cl)ccc(Br)cc1)]&#39;) print([m.HasSubstructMatch(p) for m in ms]) . [True, True, False] . So that does what we want, but it only handles six rings where every atom is a C. That second part is easy enough to change in the SMARTS, but handling other ring sizes starts to make the SMARTS really long. . A more difficult problem is that, because we use recursive SMARTS, we can&#39;t get the atoms matching the query. The pattern I used above would only return the Cl atom and the C atom it&#39;s connected to. I&#39;m not sure Alexis even wanted to do that, but by this point I was interested in the problem and decided to write some Python to solve the problem flexibly. . Here we go. . Before introducing the code and showing what it can do, a quick intro on the two pieces of functionality I&#39;m going to be using from Python&#39;s itertools module. These are really useful. . Let&#39;s start with using itertools to flatten a sequence of sequences: . import itertools seqs = [[1,2,3],[&#39;a&#39;,&#39;b&#39;],[10,20]] list(itertools.chain.from_iterable(seqs)) . [1, 2, 3, &#39;a&#39;, &#39;b&#39;, 10, 20] . And to generate all the permutations of combinations of those sequences: . list(itertools.product(*seqs)) . [(1, &#39;a&#39;, 10), (1, &#39;a&#39;, 20), (1, &#39;b&#39;, 10), (1, &#39;b&#39;, 20), (2, &#39;a&#39;, 10), (2, &#39;a&#39;, 20), (2, &#39;b&#39;, 10), (2, &#39;b&#39;, 20), (3, &#39;a&#39;, 10), (3, &#39;a&#39;, 20), (3, &#39;b&#39;, 10), (3, &#39;b&#39;, 20)] . Ok, that&#39;s the background, let&#39;s define the functions we&#39;ll use: . import itertools def getAromaticRings(mol): &quot;&quot;&quot; generator returning all aromatic rings (=only aromatic bonds) in a molecule Parameters - mol : Mol Yields set IDs of the atoms in an aromatic ring &quot;&quot;&quot; ri = mol.GetRingInfo() for ring in ri.BondRings(): ats = set() isArom = True for bi in ring: bnd = mol.GetBondWithIdx(bi) if not bnd.GetIsAromatic(): isArom = False break ats.add(bnd.GetBeginAtomIdx()) ats.add(bnd.GetEndAtomIdx()) if isArom: yield ats def getSharedRings(mol,queries,rings=None,excludeQueries=None): &quot;&quot;&quot; generator returning all rings that contain all the atoms defined in queries the first atom matching each query should be in the ring Parameters - mol : Mol queries : sequence of Mols rings : list/tuple/set of list/tuple/sets, optional sequence of rings defined by sequences of atom ids If this isn&#39;t provided, all of the molecule&#39;s rings will be used excludeQueries : sequence of Mols, optional any ring containing an atom matching the first atom in any of these queries will be excluded Yields - set containing atom IDs for a matching ring &quot;&quot;&quot; if rings is None: rings = mol.GetRingInfo().AtomRings() alreadySeen = [] rings = [set(x) for x in rings] matchSets = [[x[0] for x in mol.GetSubstructMatches(q)] for q in queries] if excludeQueries is not None: exclude = [[x[0] for x in mol.GetSubstructMatches(q)] for q in excludeQueries] # flatten the lists of matches into a set: exclude = set(itertools.chain.from_iterable(exclude)) else: exclude = set() for combo in itertools.product(*matchSets): scombo = set(combo) if len(scombo) &lt; len(combo): # degenerate: continue for ring in rings: if ring in alreadySeen: continue if scombo.issubset(ring) and exclude.isdisjoint(ring): alreadySeen.append(ring) yield ring def drawMolWithRings(mol,rings): &quot;&quot;&quot; draws a molecule with a set of rings highlighted Parameters - mol : Mol rings : list/tuple/set of list/tuple/sets sequence of rings defined by sequences of atom IDs Returns - Image &quot;&quot;&quot; bondsToHighlight=[] for bnd in mol.GetBonds(): keep = False ats = set([bnd.GetBeginAtomIdx(),bnd.GetEndAtomIdx()]) for ring in rings: if ats.issubset(ring): keep = True break if keep: bondsToHighlight.append(bnd.GetIdx()) highlightAtoms = list(itertools.chain.from_iterable(rings)) tmol = Draw.PrepareMolForDrawing(mol) d2d = Draw.MolDraw2DCairo(300, 250) d2d.DrawMolecule(tmol, highlightAtoms=highlightAtoms, highlightBonds = bondsToHighlight) d2d.FinishDrawing() return Draw._drawerToImage(d2d) . This is the molecule we&#39;ll work with: . mol = Chem.MolFromSmiles(&#39;c1c(Cl)cc(Br)c2c1CCc3c2cc(Cl)c4c3CCC(Cl)C4Br&#39;) mol . Show what the getAromaticRings() function returns here: . rings = list(getAromaticRings(mol)) rings . [{0, 1, 3, 4, 6, 7}, {10, 11, 12, 13, 15, 16}] . We can use drawMolWithRings() to highlight those atoms: . drawMolWithRings(mol,rings) . Now let&#39;s look at Alexis&#39; question: find all the aromatic rings that have a Cl and a Br attached: . matches = list(getSharedRings(mol,[Chem.MolFromSmarts(sma) for sma in (&#39;[a]-Cl&#39;,&#39;[a]-Br&#39;)], rings=getAromaticRings(mol))) print(matches) drawMolWithRings(mol,matches) . [{0, 1, 3, 4, 6, 7}] . What about aromatic rings that have both a Cl and an aliphatic C attached? . matches = list(getSharedRings(mol,[Chem.MolFromSmarts(sma) for sma in (&#39;[a]-Cl&#39;,&#39;[a]-C&#39;)], rings=getAromaticRings(mol))) print(matches) drawMolWithRings(mol,matches) . [{0, 1, 3, 4, 6, 7}, {16, 10, 11, 12, 13, 15}] . What about just finding any rings (not just aromatic) that have both Cl and Br connected? . Here we just drop the rings argument to getSharedRings(), it will use all of the molecule&#39;s rings: . matches = list(getSharedRings(mol,[Chem.MolFromSmarts(sma) for sma in (&#39;[*]-Cl&#39;,&#39;[*]-Br&#39;)])) print(matches) drawMolWithRings(mol,matches) . [{0, 1, 3, 4, 6, 7}, {15, 16, 17, 18, 19, 21}] . We can also find any rings that have a Cl, but not a Br: . matches = list(getSharedRings(mol,[Chem.MolFromSmarts(sma) for sma in (&#39;[*]-Cl&#39;,)], excludeQueries=[Chem.MolFromSmarts(sma) for sma in (&#39;[*]-Br&#39;,)])) print(matches) drawMolWithRings(mol,matches) . [{10, 11, 12, 13, 15, 16}] . We aren&#39;t limited to just six membered rings, of course. Go back to the original query for aromatic rings with both Cl and Br attached: . mol = Chem.MolFromSmiles(&#39;Clc1[nH]c(Br)c(c2ccc(Cl)c(Br)c2)c1&#39;) matches = list(getSharedRings(mol,[Chem.MolFromSmarts(sma) for sma in (&#39;[*]-Cl&#39;,&#39;[*]-Br&#39;)], rings=getAromaticRings(mol))) print(matches) drawMolWithRings(mol,matches) . [{1, 2, 3, 5, 14}, {6, 7, 8, 9, 11, 13}] . What about aromatic rings that have both Cl and Br attached, but that don&#39;t contain a heteroatom? . mol = Chem.MolFromSmiles(&#39;Clc1[nH]c(Br)c(c2ccc(Cl)c(Br)c2)c1&#39;) matches = list(getSharedRings(mol,[Chem.MolFromSmarts(sma) for sma in (&#39;[*]-Cl&#39;,&#39;[*]-Br&#39;)], rings=getAromaticRings(mol), excludeQueries=[Chem.MolFromSmarts(sma) for sma in (&#39;[a;!#6]&#39;,)])) print(matches) drawMolWithRings(mol,matches) . [{6, 7, 8, 9, 11, 13}] . Hopefully there&#39;s some useful stuff in here for you! .",
            "url": "https://greglandrum.github.io/rdkit-blog/substructure/tutorial/2020/01/30/finding-regioisomers.html",
            "relUrl": "/substructure/tutorial/2020/01/30/finding-regioisomers.html",
            "date": " • Jan 30, 2020"
        }
        
    
  
    
        ,"post7": {
            "title": "Trying out the new tautomer canonicalization code",
            "content": "During the 2018 RDKit Google Summer of Code (GSoC) project to port MolVS to C++, doing the tautomer enumeration and canonicalization were stretch goals. Susan actually managed to complete the tautomer enumeration, but since canonicalization wasn&#39;t complete, we didn&#39;t publicize this particularly widely. As part of the work for the 2020.03 release, I implemented Matt&#39;s canonicalization scheme and we recently merged that into the RDKit core. Since this is a topic that may be contentious, and since making changes to the canonicalization algorithm post-release will have be done very deliberately, I&#39;d like to collect some feedback before we do the release in a couple of months. . The implementation attempts to exactly duplicate what is currently being done in MolVS. Here&#39;s how Matt describes the process in the MolVS documentation: . Enumerate all possible tautomers using transform rules. | Use scoring system to determine canonical tautomer. | Canonical tautomer should be “reasonable” from a chemist’s point of view, but isn’t guaranteed to be the most energetically favourable. | The scoring scheme: . aromatic ring (defined by all bonds being aromatic) consisting entirely of carbons: 250 points | other aromatic rings : 100 points | a set of substructures are scored (if present). Here&#39;s the current (as of this writing) set of substructures and their associated scores (these are defined here): . {&quot;benzoquinone&quot;, &quot;[#6]1([#6]=[#6][#6]([#6]=[#6]1)=,:[N,S,O])=,:[N,S,O]&quot;, 25}, {&quot;oxim&quot;, &quot;[#6]=[N][OH]&quot;, 4}, {&quot;C=O&quot;, &quot;[#6]=,:[#8]&quot;, 2}, {&quot;N=O&quot;, &quot;[#7]=,:[#8]&quot;, 2}, {&quot;P=O&quot;, &quot;[#15]=,:[#8]&quot;, 2}, {&quot;C=hetero&quot;, &quot;[#6]=[!#1;!#6]&quot;, 1}, {&quot;methyl&quot;, &quot;[CX4H3]&quot;, 1}, {&quot;guanidine terminal=N&quot;, &quot;[#7][#6](=[NR0])[#7H0]&quot;, 1}, {&quot;guanidine endocyclic=N&quot;, &quot;[#7;R][#6;R]([N])=[#7;R]&quot;, 2}, {&quot;aci-nitro&quot;, &quot;[#6]=[N+]([O-])[OH]&quot;, -4}}; . | one point is subtracted for each H attached to P, S, Se, or Te . | . The highest scoring tautomer is selected. In the event of ties, the tautomer with the lexicographically smaller canonical SMILES is picked. . If this is something you feel strongly about, please try the code out and see what you think. If you see behavior you really don&#39;t like, or that you think is a bug, please add a comment to the associated issue in github: https://github.com/rdkit/rdkit/issues/2908 (preferred) or reply to the thread that I will create on the rdkit-discuss mailing list. . Remember that the goal of the exercise here is not to produce the &quot;best&quot; tautomer, but to produce a canonical one (always the same result for molecules which are tautomerically equivalent). We hope that this is also reasonable - in that it doesn&#39;t make a chemist&#39;s eyes burn - but that&#39;s not the primary goal. . So how can you try it out? . This is C++ code, so you need an RDKit build done from the github master. I&#39;ve done conda builds and made them available for people to try. . At the moment I&#39;ve only built the beta version for python 3.7 on linux and windows. If you would like to do some testing on the Mac, let me know and I can do a build there too. . Here&#39;s how to setup a conda environment to use the beta: . % conda create -n py37_tautomer_beta python=3.7 jupyter % conda activate py37_tautomer_beta % conda install -c rdkit/label/beta rdkit . Ok, let&#39;s look at some examples: . from rdkit import Chem from rdkit.Chem.Draw import IPythonConsole from rdkit.Chem import Draw import rdkit print(rdkit.__version__) . 2020.03.1dev1 . RDKit WARNING: [11:00:33] Enabling RDKit 2020.03.1dev1 jupyter extensions . from rdkit.Chem.MolStandardize import rdMolStandardize . enumerator = rdMolStandardize.TautomerEnumerator() . m = Chem.MolFromSmiles(&#39;Oc1c(cccc3)c3nc2ccncc12&#39;) m . Get the canonical tautomer: . enumerator.Canonicalize(m) . The canonicalizer starts by enumerating a molecule&#39;s tautomers. If you want to see those, you can use the Enumerate() method: . tauts = enumerator.Enumerate(m) Draw.MolsToGridImage(tauts) . I find this function, which reorders the list of tautomers so that the canonical one is in the first position, really useful: . def reorderTautomers(m): enumerator = rdMolStandardize.TautomerEnumerator() canon = enumerator.Canonicalize(m) csmi = Chem.MolToSmiles(canon) res = [canon] tauts = enumerator.Enumerate(m) smis = [Chem.MolToSmiles(x) for x in tauts] stpl = sorted((x,y) for x,y in zip(smis,tauts) if x!=csmi) res += [y for x,y in stpl] return res . So now we can display all the tautomers found for a molecule. The first one drawn is the canonical one: . Draw.MolsToGridImage(reorderTautomers(m)) . Draw.MolsToGridImage(reorderTautomers(Chem.MolFromSmiles(&#39;CN=c1nc[nH]cc1&#39;))) . Draw.MolsToGridImage(reorderTautomers(Chem.MolFromSmiles(&#39;CC=CO&#39;))) . As an aside, it&#39;s worth noticing that double bond stereochemistry is removed in all tautomers if the double bond is involved in the tautomerization: . m = Chem.MolFromSmiles(&#39;C/C=C(/O)F&#39;) tauts = reorderTautomers(m) print(&#39;Original SMILES:&#39;,Chem.MolToSmiles(m)) print(&#39;Tautomers (canonical first):&#39;,[Chem.MolToSmiles(x) for x in tauts]) . Original SMILES: C/C=C(/O)F Tautomers (canonical first): [&#39;CCC(=O)F&#39;, &#39;CC=C(O)F&#39;] .",
            "url": "https://greglandrum.github.io/rdkit-blog/prototypes/technical/2020/01/25/trying-the-tautomer-canonicalization-code.html",
            "relUrl": "/prototypes/technical/2020/01/25/trying-the-tautomer-canonicalization-code.html",
            "date": " • Jan 25, 2020"
        }
        
    
  
    
        ,"post8": {
            "title": "Some thoughts on the performance of the RDKit cartridge",
            "content": "EDITED on 23.01.2020 John Mayfield pointed out that the way I had constructed the set of 10 million molecules wasn’t reproducible. This update fixes that, but it also changes the results. . It’s been a while since I did a post about the cartridge! This one is a little bit ranty, but hopefully it’s still useful. . Some background and disclaimers . I normally do performance testing on the cartridge using ChEMBL, but since that’s “only” around 1.7 million compounds I wanted to try something a bit bigger. But how big? I don’t see the point in shoving 100 million compounds (or a billion) into PostgreSQL (there’s a mini-rant explaining this at the bottom of the post), so I went with 10 million. That’s more than five times bigger than ChEMBL, but it’s still not unimaginable that you’d actually have a relational schema with a molecule table this size that has data about most of those molecules in separate tables (again, see the mini-rant). . My goal here is to get a sense for what kind of performance you can expect for doing “normal” chemical queries using a local PostgreSQL instance without having to spend time optimizing the database or hardware configuration. I generated all the numbers below on my Linux desktop - which is 4-5 years old at this point - using an out-of-the-box install of PostgreSQL 12 (the only configuration tuning was to increase the size of shared_buffers to 4096M and work_mem as described in the RDKit docs). I was also using the machine for other things (like reading email or writing this post in Chrome) while these queries ran, so the numbers are really just ballpark estimates. . So which molecules to use? Rather than agonizing overly much about this, I just grabbed a PubChem Compound SMILES dump and took the first 10 million molecules from that. . I hedged above by saying “normal” chemical queries. I have a longer rant about that topic that I will spare you the details of, but I generally think that including worst-case queries (i.e. things that return tens or hundreds of thousands of rows) in real-world benchmarking examples is pointless. It’s definitely useful to understand the worst-case performance of a system, but that’s not what I’m doing here. So my queries will often limit the number of rows returned to what I think is a “reasonable” number for interactive usage. . Creating the database . This tends to be time consuming, particularly creating the molecule index. Start by creating the database from the command line and loading all of the raw data: . glandrum@otter:/tmp/pubchem_load$ createdb pubchem_compound glandrum@otter:/tmp/pubchem_load$ psql -c &#39;create extension rdkit&#39; pubchem_compound CREATE EXTENSION glandrum@otter:/tmp/pubchem_load$ psql -c &#39;create table raw_data (id SERIAL,cid integer, smiles text)&#39; pubchem_compound CREATE TABLE glandrum@otter:/tmp/pubchem_load$ zcat CID-SMILES.gz | sed &#39;s/ / /g&#39; | psql -c &quot;copy raw_data (cid,smiles) from stdin with delimiter E&#39; t&#39;&quot; pubchem_compound COPY 102397130 . Now create the molecule table and build the index: . pubchem_compound=# alter table raw_data add primary key (cid); ALTER TABLE pubchem_compound=# timing Timing is on. pubchem_compound=# select * into mols from (select cid,mol_from_smiles(smiles::cstring) m from raw_data order by cid limit 10000000) tmp where m is not null; ... lots of info about failing molecules deleted here WARNING: could not create molecule from SMILES &#39;[B+]12(CC3CC(C1)CC(C2)C3)NCC[O-]&#39; WARNING: could not create molecule from SMILES &#39;[B+]12(CC3CC(C1)CC(C2)C3)NCCO&#39; SELECT 9999165 Time: 1722464.775 ms (28:42.465) pubchem_compound=# create index molidx on mols using gist(m); CREATE INDEX Time: 3735718.147 ms (01:02:15.718) . Add fingerprints and their index along with the primary keys we’ll use to link things: . pubchem_compound=# create index fps_mfp2_idx on fps using gist(mfp2); CREATE INDEX Time: 155112.279 ms (02:35.112) pubchem_compound=# alter table mols add primary key (cid); ALTER TABLE Time: 44271.680 ms (00:44.272) pubchem_compound=# alter table fps add primary key (cid); ALTER TABLE Time: 27675.441 ms (00:27.675) . Now let’s do some queries. . Substructure queries . Note that all of the results below are done with a “warm” disk cache: I ran a substructure search and similarity search to try and ensure that at least parts of the indices are being cached by the operating system. . Picking the queries for a demo is always tricky, and can obviously completely slant the results one way or another, so I went to the ASAP page for J Med Chem and pulled stuff from there. . Let’s start with a query for parts of the “head” and “gate” from this paper: https://pubs.acs.org/doi/10.1021/acs.jmedchem.9b01912 . pubchem_compound=# select * from mols where m@&gt;&#39;CC1=C(C=C(C=C1)C(N)=O)C#CC1=CN=CC=C1&#39; limit 10; cid | m -+- 11526637 | Cc1ccc(C(=O)Nc2cc(OC[C@@H]3CCCN3C)cc(C(F)(F)F)c2)cc1C#Cc1cnc2nc[nH]c2c1 (1 row) Time: 5359.046 ms (00:05.359) . Here’s the one hit: . . Now the core from: https://pubs.acs.org/doi/10.1021/acs.jmedchem.9b01427 . pubchem_compound=# select * from mols where m@&gt;&#39;CC1=CC2=C(S1)C(=O)NC(C)=N2&#39; limit 10; cid | m -+ 3758971 | CCOC(=O)C1CCCn2c1nc1cc(-c3ccccc3)sc1c2=O 10622152 | COc1ccc(NC(=S)Nn2c(C)nc3cc(-c4ccccc4)sc3c2=O)cc1 1040399 | COC(=O)[C@@H]1CCc2nc3cc(-c4ccc(OC)cc4)sc3c(=O)n21 1040400 | COC(=O)[C@H]1CCc2nc3cc(-c4ccc(OC)cc4)sc3c(=O)n21 3310123 | O=c1c2sc(-c3ccccc3)cc2nc2n1CCCCC2 4376566 | CCOC(=O)C1CCCn2c1nc1cc(-c3ccc(OC)cc3)sc1c2=O 10574247 | COc1ccccc1NC(=S)Nn1c(C)nc2cc(-c3ccccc3)sc2c1=O 11404362 | Cc1cc2nc(-c3ccccc3)n(-c3ccccc3)c(=O)c2s1 10716322 | Cc1cccc(NC(=S)Nn2c(C)nc3cc(-c4ccccc4)sc3c2=O)c1 661611 | COc1ccc(-c2cc3nc4n(c(=O)c3s2)CCOC4)cc1 (10 rows) Time: 6.532 ms . And the results: . . And, finally, the core from: https://pubs.acs.org/doi/10.1021/acs.jmedchem.9b01684 . pubchem_compound=# select * from mols where m@&gt;&#39;CN1C(=O)N(C)C2=C1C=NC(N)=N2&#39; limit 10; cid | m -+ 10359733 | C=CCn1c(=O)n(CCCCCCCC)c2nc(N)nc(Cl)c21 10452174 | Nc1nc2c(c(=O)n1N)n(CCCl)c(=O)n2[C@@H]1O[C@H](CO)[C@@H](O)[C@H]1O 10048317 | Nc1nc2c(c(=O)n1N)n(C/C=C/c1ccccc1)c(=O)n2[C@@H]1O[C@H](CO)[C@@H](O)[C@H]1O 10454396 | [N-]=[N+]=NCC(O)Cn1c(=O)n([C@@H]2O[C@H](CO)[C@@H](O)[C@H]2O)c2nc(N)n(N)c(=O)c21 10476329 | Nc1nc2c(c(=O)n1N)n(Cc1ccccc1)c(=O)n2[C@@H]1O[C@H](CO)[C@@H](O)[C@H]1O 11428584 | C=CCn1c(=O)n([C@@H]2O[C@H](CO)[C@@H](O)[C@H]2O)c2nc(N)nc(OCC)c21 11453816 | C=CCn1c(=O)n([C@@H]2O[C@H](CO)[C@@H](O)[C@H]2O)c2nc(N)nc(OCN(C)C(=O)OCC)c21 9980347 | COc1ccc(Cn2c(=O)n([C@@H]3O[C@H](CO)[C@@H](O)[C@H]3O)c3nc(N)n(N)c(=O)c32)cc1 10085856 | Cn1c(=O)n2c3c1c(=O)nc(N)n3C[C@H]1O[C@@H]2[C@H](O)[C@@H]1O 9994808 | C=CCn1c(=O)n(CCCCO)c2nc(N)nc(Cl)c21 (10 rows) Time: 107.934 ms . And the first results: . . These queries are, in general, pretty quick. I’m certainly likely to spend more time looking at the results than I am waiting for them to come back. . One point it’s worth making is that queries that don’t return any results tend to be pretty fast. Here’s an example of that: . pubchem_compound=# select * from mols where m@&gt;&#39;O1C=NC2=C1N=C1N=CN=CC1=N2&#39; limit 5; cid | m --+ (0 rows) Time: 9.778 ms . Note that this is definitely not always true… the index does not work particularly well for queries that have massively repeating common substructures: . pubchem_compound=# select * from mols where m@&gt;&#39;COCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCOCCOCOCOCOCOCCO&#39; limit 5; cid | m --+ (0 rows) Time: 150521.647 ms (02:30.522) . Remember what I said about about worst-case performance? There ya go. . Similarity queries . Now let’s do some similarity searches using the molecule drawn in the graphical abstract as queries. For this blog post I’m going to use the cartridge’s “neighbor” operator &lt;%&gt; to order the results and allow the N closest neighbors of each query molecule to be retrieved. Here’s the simple SQL function that I use for doing that: . pubchem_compound=# pubchem_compound=# create or replace function get_mfp2_neighbors2(smiles text) returns table(cid integer, m mol, similarity double precision) as $$ select cid,m,tanimoto_sml(morganbv_fp(mol_from_smiles($1::cstring)),mfp2) as similarity from fps join mols using (cid) order by morganbv_fp(mol_from_smiles($1::cstring))&lt;%&gt;mfp2; $$ language sql stable ; . That’s adapted from the function get_mfp2_neighbors that is in the RDKit cartridge documentation. . Let’s start with a query for the five nearest neighbors of balovaptan (https://pubs.acs.org/doi/10.1021/acs.jmedchem.9b01478): . pubchem_compound=# select * from get_mfp2_neighbors2(&#39;CN1CC2=NN=C(C3CCC(CC3)OC3=CC=CC=N3)N2C2=CC=C(Cl)C=C2C1&#39;) limit 5; cid | m | similarity -+-+-- 11237434 | CN1Cc2cc(Cl)ccc2-n2c(nnc2C2CCN(c3ccccn3)CC2)C1 | 0.7049180327868853 11237433 | CN1Cc2cc(Cl)ccc2-n2c(nnc2C2CCN(c3ccccn3)CC2)C1.Cl.Cl.Cl | 0.6935483870967742 10070061 | CN1CCc2cc(Cl)ccc2-n2c(nnc2C2CCN(c3ccccn3)CC2)C1 | 0.6212121212121212 11270862 | Cc1ccccc1CC(=O)N1CCC(c2nnc3n2-c2ccc(Cl)cc2CN(C)C3)CC1 | 0.5797101449275363 11442570 | CN1Cc2cc(Cl)ccc2-n2c(nnc2C2CCN(C(=O)c3c[nH]c4ccccc34)CC2)C1 | 0.5774647887323944 (5 rows) Time: 239.879 ms . It’s easy (and quick) to expand that to the ten nearest neighbors: . pubchem_compound=# select * from get_mfp2_neighbors2(&#39;CN1CC2=NN=C(C3CCC(CC3)OC3=CC=CC=N3)N2C2=CC=C(Cl)C=C2C1&#39;) limit 10; cid | m | similarity -+-+-- 11237434 | CN1Cc2cc(Cl)ccc2-n2c(nnc2C2CCN(c3ccccn3)CC2)C1 | 0.7049180327868853 11237433 | CN1Cc2cc(Cl)ccc2-n2c(nnc2C2CCN(c3ccccn3)CC2)C1.Cl.Cl.Cl | 0.6935483870967742 10070061 | CN1CCc2cc(Cl)ccc2-n2c(nnc2C2CCN(c3ccccn3)CC2)C1 | 0.6212121212121212 11270862 | Cc1ccccc1CC(=O)N1CCC(c2nnc3n2-c2ccc(Cl)cc2CN(C)C3)CC1 | 0.5797101449275363 11442570 | CN1Cc2cc(Cl)ccc2-n2c(nnc2C2CCN(C(=O)c3c[nH]c4ccccc34)CC2)C1 | 0.5774647887323944 11486399 | CN1Cc2cc(Cl)ccc2-n2c(nnc2C2CCN(C(=O)CC3CC3)CC2)C1 | 0.5757575757575758 11349733 | CCCC(=O)N1CCC(c2nnc3n2-c2ccc(Cl)cc2CN(C)C3)CC1 | 0.5757575757575758 11305733 | CN1Cc2cc(Cl)ccc2-n2c(nnc2C2CCN(C(=O)c3cc4ccccc4[nH]3)CC2)C1 | 0.5694444444444444 11166614 | CN1Cc2cc(Cl)ccc2-n2c(nnc2C2CCN(C(=O)C3(C)CCCCC3)CC2)C1 | 0.5671641791044776 10028677 | CN1CCOC(CN2Cc3cc(Cl)ccc3-n3c(nnc3C3CCN(c4ccccn4)CC3)C2)C1 | 0.5616438356164384 (10 rows) Time: 189.425 ms . Here are the first few of those, along with the similarity values: . . The five nearest neighbors for AZD7648 (https://pubs.acs.org/doi/10.1021/acs.jmedchem.9b01684) aren’t particularly similar: . pubchem_compound=# select * from get_mfp2_neighbors2(&#39;CN1C(=O)N(C2CCOCC2)C2=C1C=NC(NC1=CN3N=CN=C3C=C1C)=N2&#39;) limit 5; cid | m | similarity -+--+ 11504903 | Cn1c(=O)c(=O)n(C2CCCC2)c2nc(Nc3ccc(C(=O)NC4CCC(N5CCOCC5)CC4)cc3)ncc21 | 0.4166666666666667 11406590 | Cn1c(=O)c(Oc2ccc(F)cc2F)cc2cnc(NC3CCOCC3)nc21 | 0.3924050632911392 10230233 | Cc1cc(=O)n(C2CCCC2)c2nc(Nc3ccc(N4CCC(CCCN5CCOCC5)CC4)cc3)ncc12 | 0.3595505617977528 9801449 | Cc1nc2cnc(Nc3ccc(N4CCOCC4)cc3)nc2n(C2CCCC2)c1=O | 0.35443037974683544 10224126 | Cc1cc(=O)n(C2CCCC2)c2nc(Nc3ccc(N4CCOCC4)c(F)c3)ncc12 | 0.3488372093023256 (5 rows) Time: 219.653 ms . As we can see: . . The performance of these queries isn’t quite as good as what you can do with specialized open-source tools like chemfp, gpusimilarity, or FPSim2, but I think it’s reasonable for retrieving a set of neighbors that I’m then going to do (probably more time consuming) further analysis on. . Note that the similarity queries were considerably slower in the original version of this blog post. This was likely due to me doing a bad job of warming up the disk cache. . Some technical details: . Sizes of the tables and indices . pubchem_compound=# d+ List of relations Schema | Name | Type | Owner | Size | Description --+--+-+-++- public | fps | table | glandrum | 964 MB | public | mols | table | glandrum | 4236 MB | public | raw_data | table | glandrum | 9091 MB | public | raw_data_id_seq | sequence | glandrum | 8192 bytes | (4 rows) pubchem_compound=# di+ List of relations Schema | Name | Type | Owner | Table | Size | Description --++-+-+-++- public | fps_mfp2_idx | index | glandrum | fps | 1226 MB | public | fps_pkey | index | glandrum | fps | 214 MB | public | molidx | index | glandrum | mols | 4060 MB | public | mols_pkey | index | glandrum | mols | 214 MB | public | raw_data_pkey | index | glandrum | raw_data | 2193 MB | (5 rows) . Performance of the substructure indices . Here are results for the substructure queries executed above. For the purposes of this analysis I removed the limit on the query: . pubchem_compound=# explain analyze select * from mols where m@&gt;&#39;CC1=C(C=C(C=C1)C(N)=O)C#CC1=CN=CC=C1&#39;; QUERY PLAN Bitmap Heap Scan on mols (cost=2157.91..37897.03 rows=9999 width=398) (actual time=167.546..168.902 rows=1 loops=1) Recheck Cond: (m @&gt; &#39;Cc1ccc(C(N)=O)cc1C#Cc1cccnc1&#39;::mol) Rows Removed by Index Recheck: 328 Heap Blocks: exact=309 -&gt; Bitmap Index Scan on molidx (cost=0.00..2155.41 rows=9999 width=0) (actual time=137.703..137.703 rows=329 loops=1) Index Cond: (m @&gt; &#39;Cc1ccc(C(N)=O)cc1C#Cc1cccnc1&#39;::mol) Planning Time: 0.119 ms Execution Time: 169.178 ms (8 rows) pubchem_compound=# explain analyze select * from mols where m@&gt;&#39;CC1=CC2=C(S1)C(=O)NC(C)=N2&#39;; QUERY PLAN -- Bitmap Heap Scan on mols (cost=2157.91..37897.03 rows=9999 width=398) (actual time=436.998..510.558 rows=46 loops=1) Recheck Cond: (m @&gt; &#39;Cc1nc2cc(C)sc2c(=O)[nH]1&#39;::mol) Rows Removed by Index Recheck: 14 Heap Blocks: exact=55 -&gt; Bitmap Index Scan on molidx (cost=0.00..2155.41 rows=9999 width=0) (actual time=436.902..436.902 rows=60 loops=1) Index Cond: (m @&gt; &#39;Cc1nc2cc(C)sc2c(=O)[nH]1&#39;::mol) Planning Time: 0.113 ms Execution Time: 510.801 ms (8 rows) pubchem_compound=# explain analyze select * from mols where m@&gt;&#39;CN1C(=O)N(C)C2=C1C=NC(N)=N2&#39;; QUERY PLAN - Bitmap Heap Scan on mols (cost=2157.91..37897.03 rows=9999 width=398) (actual time=5111.590..5113.136 rows=38 loops=1) Recheck Cond: (m @&gt; &#39;Cn1c(=O)n(C)c2nc(N)ncc21&#39;::mol) Rows Removed by Index Recheck: 10 Heap Blocks: exact=48 -&gt; Bitmap Index Scan on molidx (cost=0.00..2155.41 rows=9999 width=0) (actual time=5081.767..5081.768 rows=48 loops=1) Index Cond: (m @&gt; &#39;Cn1c(=O)n(C)c2nc(N)ncc21&#39;::mol) Planning Time: 0.058 ms Execution Time: 5113.296 ms (8 rows) . All of those show that the index is doing a reasonably good job of pruning compounds - the worst case query (the first one) only ends up trying at 329 substructure queries (instead of 10 million!) to find the 1 actual match. . Warming up the disk cache . There are tons of ways to do this. Here’s the approach I used for this post: . pubchem_compound=# select cid,mol_murckoscaffold(m) scaff into temporary table scaffs from mols order by cid desc limit 10; SELECT 10 pubchem_compound=# select count(*) from mols cross join scaffs where mols.m@&gt;scaffs.scaff; count -- 178828 (1 row) pubchem_compound=# select * into blah from fps order by cid desc limit 10; SELECT 10 pubchem_compound=# select count(*) from fps cross join blah where blah.mfp2%fps.mfp2; count - 401 (1 row) . That takes ~10 minutes to run for me. . Doing the queries and making the images . Since I’m not doing this one from a jupyter notebook, here’s the code snippet I’m using in jupyter to do the substructure queries and display the results: . q=&#39;CN1C(=O)N(C)C2=C1C=NC(N)=N2&#39; t1=time.time() d = %sql postgresql://localhost/pubchem_compound select * from mols where m@&gt;:q limit 10; t2 = time.time() print(f&#39;{t2-t1:.2f} seconds&#39;) ms = [Chem.MolFromSmiles(x) for x in [q]+[x[1] for x in d]] ls = [&#39;query&#39;]+[str(x[0]) for x in d] Draw.MolsToGridImage(ms[:8],legends=ls,molsPerRow=4) . And the equivalent thing for nearest-neighbor queries: . q=&#39;CN1CC2=NN=C(C3CCC(CC3)OC3=CC=CC=N3)N2C2=CC=C(Cl)C=C2C1&#39; t1=time.time() d = %sql postgresql://localhost/pubchem_compound select * from get_mfp2_neighbors2(:q) limit 10; t2 = time.time() print(f&#39;{t2-t1:.2f} seconds&#39;) ms = [Chem.MolFromSmiles(x) for x in [q]+[x[1] for x in d]] ls = [&#39;query&#39;]+[f&#39;{x[0]} {x[2] :.2f}&#39; for x in d] Draw.MolsToGridImage(ms[:8],legends=ls,molsPerRow=4) . Both of these are using the fantastic sql-magic for jupyter from Catherine Devlin. . Mini-rant . PostgreSQL is a general purpose relational database, it lets you store collections of tables with links (relations) between them and makes it easy to do queries that combine data across tables. If you have data on a bunch of molecules that can’t be logically captured in a single table (like ChEMBL!), a relational database is a great place to put that. If you have a single table with a bunch of columns (i.e. molecules and values or fingerprints computed from them), you may want to look to another type of system. If you have a huge number of rows that you are really only interested in doing chemical queries (substructure and similarity searches) against, and you care about performance, then you almost certainly should be using a specialized system. There are plenty to choose from! .",
            "url": "https://greglandrum.github.io/rdkit-blog/cartridge/2020/01/21/some-thoughts-on-cartridge-performance.html",
            "relUrl": "/cartridge/2020/01/21/some-thoughts-on-cartridge-performance.html",
            "date": " • Jan 21, 2020"
        }
        
    
  
    
        ,"post9": {
            "title": "Similarity maps with the new drawing code",
            "content": "As part of the 2019.09 release we added a C++ implementation of the RDKit&#39;s similarity map functionality (https://jcheminf.biomedcentral.com/articles/10.1186/1758-2946-5-43). I forgot to mention this during the &quot;What&#39;s New&quot; bit of my presentation at the UGM, but I think it&#39;s worth calling attention to. So here&#39;s a quick blog post. . from rdkit import Chem from rdkit.Chem import Draw from rdkit.Chem.Draw import SimilarityMaps from IPython.display import SVG import io from PIL import Image import numpy as np import rdkit print(rdkit.__version__) . RDKit WARNING: [11:53:45] Enabling RDKit 2019.09.2 jupyter extensions . 2019.09.2 . I start by using &quot;classic&quot; similarity map functionality to show why atorvastatin (Lipitor) and rosuvastatin (Crestor) are similar to each other when using the Morgan fingerprint. . Here are the two molecules: . atorvastatin = Chem.MolFromSmiles(&#39;O=C(O)C[C@H](O)C[C@H](O)CCn2c(c(c(c2c1ccc(F)cc1)c3ccccc3)C(=O)Nc4ccccc4)C(C)C&#39;) rosuvastatin = Chem.MolFromSmiles(&#39;OC(=O)C[C@H](O)C[C@H](O) C=C c1c(C(C)C)nc(N(C)S(=O)(=O)C)nc1c2ccc(F)cc2&#39;) Draw.MolsToGridImage((atorvastatin,rosuvastatin)) . To use the new drawing code, we create a Draw2D object and pass that to SimilarityMaps.GetSimilarityMapForFingerprint: . def show_png(data): bio = io.BytesIO(data) img = Image.open(bio) return img . d = Draw.MolDraw2DCairo(400, 400) _, maxWeight = SimilarityMaps.GetSimilarityMapForFingerprint(atorvastatin, rosuvastatin, lambda m, i: SimilarityMaps.GetMorganFingerprint(m, i, radius=2, fpType=&#39;bv&#39;), draw2d=d) d.FinishDrawing() show_png(d.GetDrawingText()) . We can do the same thing with count-based fingerprints: . d = Draw.MolDraw2DCairo(400, 400) _, maxWeight = SimilarityMaps.GetSimilarityMapForFingerprint(atorvastatin, rosuvastatin, lambda m, i: SimilarityMaps.GetMorganFingerprint(m, i, radius=2, fpType=&#39;count&#39;), draw2d=d) d.FinishDrawing() show_png(d.GetDrawingText()) . The other GetSimilarityMapFrom... functions also accept the optional draw2d argument. Here&#39;s a visualization of the contributions made by the atoms in atorvastatin to its calculatied logp value: . from rdkit.Chem import rdMolDescriptors ator_contribs = rdMolDescriptors._CalcCrippenContribs(atorvastatin) d = Draw.MolDraw2DCairo(400, 400) SimilarityMaps.GetSimilarityMapFromWeights(atorvastatin,[x[0] for x in ator_contribs],draw2d=d) d.FinishDrawing() show_png(d.GetDrawingText()) . And a couple more visualizations of various partial charge schemes. . Starting with Gasteiger-Marsilli charges: . from rdkit.Chem import rdPartialCharges rdPartialCharges.ComputeGasteigerCharges(atorvastatin) chgs = [x.GetDoubleProp(&quot;_GasteigerCharge&quot;) for x in atorvastatin.GetAtoms()] d = Draw.MolDraw2DCairo(400, 400) SimilarityMaps.GetSimilarityMapFromWeights(atorvastatin,chgs,draw2d=d) d.FinishDrawing() show_png(d.GetDrawingText()) . And also the partial charges calculated with extended Hueckel theory (eHT) using Mulliken analysis: . from rdkit.Chem import rdEHTTools from rdkit.Chem import rdDistGeom mh = Chem.AddHs(atorvastatin) rdDistGeom.EmbedMolecule(mh) _,res = rdEHTTools.RunMol(mh) static_chgs = res.GetAtomicCharges()[:atorvastatin.GetNumAtoms()] d = Draw.MolDraw2DCairo(400, 400) SimilarityMaps.GetSimilarityMapFromWeights(atorvastatin,list(static_chgs),draw2d=d) d.FinishDrawing() show_png(d.GetDrawingText()) . As one final demo, I&#39;ll use the method to visualize the variability of the eHT charges with conformation for atorvastatin. . Start by generating 10 diverse conformers, calculating the charges for each, and plotting the average: . mh = Chem.AddHs(atorvastatin) ps = rdDistGeom.ETKDGv2() ps.pruneRmsThresh = 0.5 ps.randomSeed = 0xf00d rdDistGeom.EmbedMultipleConfs(mh,10,ps) print(f&#39;Found {mh.GetNumConformers()} conformers&#39;) chgs = [] for conf in mh.GetConformers(): _,res = rdEHTTools.RunMol(mh,confId=conf.GetId()) chgs.append(res.GetAtomicCharges()[:atorvastatin.GetNumAtoms()]) chgs = np.array(chgs) mean_chgs = np.mean(chgs,axis=0) std_chgs = np.std(chgs,axis=0) d = Draw.MolDraw2DCairo(400, 400) SimilarityMaps.GetSimilarityMapFromWeights(atorvastatin,list(mean_chgs),draw2d=d) d.FinishDrawing() show_png(d.GetDrawingText()) . Found 10 conformers . That doesn&#39;t look hugely different from what we saw above. . To show the variability, plot the standard deviation of the charges across the 10 conformers: . print(std_chgs) print(max(std_chgs),min(std_chgs)) d = Draw.MolDraw2DCairo(400, 400) SimilarityMaps.GetSimilarityMapFromWeights(atorvastatin,list(std_chgs),draw2d=d) d.FinishDrawing() show_png(d.GetDrawingText()) . [0.01292592 0.00743163 0.01971312 0.01433223 0.01063085 0.01283745 0.01219511 0.00748435 0.01234194 0.01492494 0.00640842 0.02264999 0.02481744 0.00987842 0.00843151 0.01289956 0.00560632 0.00498617 0.00604883 0.005569 0.00452067 0.00796675 0.00718033 0.00581337 0.00702613 0.00634237 0.00699789 0.00539868 0.00521868 0.02412709 0.03131741 0.03709349 0.00657276 0.01175903 0.00674661 0.01012909 0.0050995 0.01139418 0.00831795 0.00581207 0.00960073] 0.03709348867462464 0.00452067345998171 . The deviations aren&#39;t huge (the printed array shows that), but the largest value is clearly the amide N. . There&#39;s definitely a ToDo here to improve the way the negative contours are drawn so that the fact that they are being drawn with dashed lines is visible. .",
            "url": "https://greglandrum.github.io/rdkit-blog/tutorial/2020/01/03/similarity-maps-with-new-drawing-code.html",
            "relUrl": "/tutorial/2020/01/03/similarity-maps-with-new-drawing-code.html",
            "date": " • Jan 3, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About this blog",
          "content": "The repo with the original Jupyter notebooks and data is here . The hub for information about the RDKit is rdkit.org . If you’re an Anaconda Python user, installing the RDKit is as simple as conda install -c conda-forge rdkit . Professional support and services for the RDKit are provided by T5 Informatics GmbH. Contact us if you are interested in RDKit support. . . This blog is powered by fastpages. .",
          "url": "https://greglandrum.github.io/rdkit-blog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://greglandrum.github.io/rdkit-blog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}